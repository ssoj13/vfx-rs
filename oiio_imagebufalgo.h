{"content":"// Copyright Contributors to the OpenImageIO project. //\nSPDX-License-Identifier: Apache-2.0 //\nhttps://github.com/AcademySoftwareFoundation/OpenImageIO // clang-format off\n#pragma once #define OPENIMAGEIO_IMAGEBUFALGO_H #if defined(_MSC_VER) // Ignore\nwarnings about DLL exported classes with member variables that are template\nclasses. // This happens with the std::vector members of PixelStats below. #\npragma warning (disable : 4251) #endif #include #include #include #include\n#include #include #include #include OIIO_NAMESPACE_3_1_BEGIN /// @defgroup\nImageBufAlgo_intro (ImageBufAlgo common principles) /// @{ /// /// This section\nexplains the general rules common to all ImageBufAlgo /// functions. Only\nexceptions to these rules will be explained in the /// subsequent listings of\nall the individual ImageBufAlgo functions. /// /// /// **Return values and error\nmessages** /// /// Most ImageBufAlgo functions that produce image data come in\ntwo forms: /// /// 1. Return an ImageBuf. /// /// The return value is a new\nImageBuf containing the result image. In /// this case, an entirely new image\nwill be created to hold the result. /// In case of error, the result image\nreturned can have any error /// conditions checked with `has_error()` and\n`geterror()`. /// /// // Method 1: Return an image result /// ImageBuf fg\n(\"fg.exr\"), bg (\"bg.exr\"); /// ImageBuf dst = ImageBufAlgo::over (fg, bg); ///\nif (dst.has_error()) /// std::cout << \"error: \" << dst.geterror() << \"\\n\"; ///\n/// 2. Pass a destination ImageBuf reference as the first parameter. /// /// The\nfunction is passed a *destination* ImageBuf where the results /// will be\nstored, and the return value is a `bool` that is `true` if /// the function\nsucceeds or `false` if the function fails. Upon failure, /// the destination\nImageBuf (the one that is being altered) will have an /// error message set. ///\n/// // Method 2: Write into an existing image /// ImageBuf fg (\"fg.exr\"), bg\n(\"bg.exr\"); /// ImageBuf dst; // will be the output image /// bool ok =\nImageBufAlgo::over (dst, fg, bg); /// if (! ok) /// std::cout << \"error: \" <<\ndst.geterror() << \"\\n\"; /// /// The first option (return an ImageBuf) is a more\ncompact and intuitive /// notation that is natural for most simple uses. But the\nsecond option /// (pass an ImageBuf& referring to an existing destination)\noffers /// additional flexibility, including more careful control over\nallocations, /// the ability to partially overwrite regions of an existing\nimage, and the /// ability for the destination image to also be one of the input\nimages /// (for example, add(A,A,B) adds B into existing image A, with no third\n/// image allocated at all). /// /// **Region of interest** /// /// Most\nImageBufAlgo functions take an optional ROI parameter that /// restricts the\noperation to a range in x, y, z, and channels. The default /// ROI (also known\nas `ROI::All()`) means no region restriction -- the /// whole image will be\ncopied or altered. /// /// For ImageBufAlgo functions that write into a\ndestination ImageBuf /// parameter and it is already initialized (i.e. allocated\nwith a /// particular size and data type), the operation will be performed on\nthe /// pixels in the destination that overlap the ROI, leaving pixels in the\n/// destination which are outside the ROI unaltered. /// /// For ImageBufAlgo\nfunctions that return an ImageBuf directly, or their /// `dst` parameter that is\nan uninitialized ImageBuf, the ROI (if set) /// determines the size of the\nresult image. If the ROI is the default /// `All`, the result image size will be\nthe union of the pixel data windows /// of the input images and have a data type\ndetermined by the data types of /// the input images. /// /// Most ImageBufAlgo\nfunctions also respect the `chbegin` and `chend` /// members of the ROI, thus\nrestricting the channel range on which the /// operation is performed. The\ndefault ROI constructor sets up the ROI /// to specify that the operation should\nbe performed on all channels of /// the input image(s). /// /// **Constant and\nper-channel values** /// /// Many ImageBufAlgo functions take per-channel\nconstant-valued arguments /// (for example, a fill color). These parameters are\npassed as /// `cspan`. These are generally expected to have length equal to the\n/// number of channels. But you may also pass a single float which will be ///\nused as the value for all channels. (More generally, what is happening /// is\nthat the last value supplied is replicated for any missing channel.) /// ///\nSome ImageBufAlgo functions have parameters of type `Image_or_Const`, /// which\nmay take either an ImageBuf reference, or a per-channel constant, /// or a\nsingle constant to be used for all channels. /// /// **Multithreading** /// ///\nAll ImageBufAlgo functions take an optional `nthreads` parameter that ///\nsignifies the maximum number of threads to use to parallelize the /// operation.\nThe default value for `nthreads` is 0, which signifies that /// the number of\nthread should be the OIIO global default set by /// `OIIO::attribute()`, which\nitself defaults to be the detected level of /// hardware concurrency (number of\ncores available). /// /// Generally you can ignore this parameter (or pass 0),\nmeaning to use all /// the cores available in order to perform the computation\nas quickly as /// possible. The main reason to explicitly pass a different\nnumber /// (generally 1) is if the application is multithreaded at a high level,\n/// and the thread calling the ImageBufAlgo function just wants to continue ///\ndoing the computation without spawning additional threads, which might /// tend\nto crowd out the other application threads. /// ///@} /// Image_or_Const:\nParameter-passing helper that is a non-owning reference /// to either an\n`ImageBuf&`, `ImageBuf*`, per-channel float constant, or a /// single float\nconstant. This lets us tame the combinatorics of functions /// where each of\nseveral input parameters may be either images or constant /// values. class\nImage_or_Const { public: struct None {}; Image_or_Const (None) : m_type(NONE) {}\nImage_or_Const (const ImageBuf &img) : m_type(IMG), m_img(&img) {}\nImage_or_Const (const ImageBuf *img) : m_type(IMG), m_img(img) {} Image_or_Const\n(cspan val) : m_type(VAL), m_val(val) {} Image_or_Const (const float& val) :\nm_type(VAL), m_val(val) {} Image_or_Const (const std::vector& val) :\nm_type(VAL), m_val(val) {} Image_or_Const (std::initializer_list val) :\nm_type(VAL), m_val(val) {} Image_or_Const (const float *v, size_t s) :\nm_type(VAL), m_val(v,s) {} Image_or_Const (const float *v, int s) : m_type(VAL),\nm_val(v,s) {} template Image_or_Const(const float (&array)[N]) :\nImage_or_Const(cspan(array)) {} bool is_img () const { return m_type == IMG; }\nbool is_val () const { return m_type == VAL; } bool is_empty () const { return\nm_type == NONE; } const ImageBuf& img () const { return *m_img; } const\nImageBuf* imgptr () const { return m_img; } cspan val () const { return m_val; }\nvoid swap (Image_or_Const &other) { std::swap (m_type, other.m_type); std::swap\n(m_img, other.m_img); std::swap (m_val, other.m_val); } private: enum Contents {\nNONE, VAL, IMG }; Contents m_type; const ImageBuf * m_img = nullptr; cspan\nm_val; }; namespace ImageBufAlgo { /// IBA::KWArgs is a span of ParamValue, used\nto pass keyword/value optional /// arguments to IBA functions. using KWArgs =\nParamValueSpan; /// Create an all-black `float` image of size and channels as\ndescribed by /// the ROI. ImageBuf OIIO_API zero (ROI roi, int nthreads=0); ///\nWrite to an existing image `dst` (allocating if it is uninitialized). bool\nOIIO_API zero (ImageBuf &dst, ROI roi={}, int nthreads=0); /// @defgroup fill\n(ImageBufAlgo::fill -- fill a region) /// @{ /// /// Fill an image region with\ngiven channel values, either returning a new /// image or altering the existing\n`dst` image within the ROI. Note that the /// values arrays start with channel\n0, even if the ROI indicates that a /// later channel is the first to be\nchanged. /// /// Three varieties of fill() exist: (a) a single set of channel\nvalues that /// will apply to the whole ROI, (b) two sets of values that will\ncreate a /// linearly interpolated gradient from top to bottom of the ROI, (c)\nfour /// sets of values that will be bilinearly interpolated across all four ///\ncorners of the ROI. ImageBuf OIIO_API fill (cspan values, ROI roi, int\nnthreads=0); ImageBuf OIIO_API fill (cspan top, cspan bottom, ROI roi, int\nnthreads=0); ImageBuf OIIO_API fill (cspan topleft, cspan topright, cspan\nbottomleft, cspan bottomright, ROI roi, int nthreads=0); bool OIIO_API fill\n(ImageBuf &dst, cspan values, ROI roi={}, int nthreads=0); bool OIIO_API fill\n(ImageBuf &dst, cspan top, cspan bottom, ROI roi={}, int nthreads=0); bool\nOIIO_API fill (ImageBuf &dst, cspan topleft, cspan topright, cspan bottomleft,\ncspan bottomright, ROI roi={}, int nthreads=0); /// @} /// Create a checkerboard\npattern of size given by `roi`, with origin given /// by the `offset` values,\nchecker size given by the `width`, `height`, /// `depth` values, and alternating\nbetween `color1[]` and `color2[]`. The /// pattern is defined in abstract \"image\nspace\" independently of the pixel /// data window of `dst` or the ROI. ImageBuf\nOIIO_API checker (int width, int height, int depth, cspan color1, cspan color2,\nint xoffset, int yoffset, int zoffset, ROI roi, int nthreads=0); /// Write to an\nexisting image `dst` (allocating if it is uninitialized). bool OIIO_API checker\n(ImageBuf &dst, int width, int height, int depth, cspan color1, cspan color2,\nint xoffset=0, int yoffset=0, int zoffset=0, ROI roi={}, int nthreads=0); ///\nReturn an image of \"noise\" in every pixel and channel specified by the /// roi.\nThere are several noise types to choose from, and each behaves /// differently\nand has a different interpretation of the `A` and `B` /// parameters: /// /// -\n\"gaussian\" adds Gaussian (normal distribution) noise values with /// mean value\nA and standard deviation B. /// - \"white\" adds independent uniformly distributed\nvalues on range /// [A,B). /// - \"uniform\" (synonym for \"white\") /// - \"blue\"\nadds \"blue noise\" uniformly distributed on range [A,B) but /// not independent;\nrather, they are chosen for good spectral /// properties for sampling and\ndither. /// - \"salt\" changes to value A a portion of pixels given by B. /// ///\nIf the `mono` flag is true, a single noise value will be applied to all ///\nchannels specified by `roi`, but if `mono` is false, a separate noise /// value\nwill be computed for each channel in the region. /// /// The random number\ngenerator is actually driven by a hash on the \"image /// space\" coordinates and\nchannel, independently of the pixel data window /// of `dst` or the ROI.\nChoosing different seed values will result in a /// different pattern, but for\nthe same seed value, the noise at a given /// pixel coordinate (x,y,z) channel c\nwill is completely deterministic and /// repeatable. ImageBuf OIIO_API noise\n(string_view noisetype, float A = 0.0f, float B = 0.1f, bool mono = false, int\nseed = 0, ROI roi={}, int nthreads=0); /// Write to an existing image `dst`\n(allocating if it is uninitialized). bool OIIO_API noise (ImageBuf &dst,\nstring_view noisetype, float A = 0.0f, float B = 0.1f, bool mono = false, int\nseed = 0, ROI roi={}, int nthreads=0); /// Return a const reference to a\nperiodic bluenoise texture with float data /// in 4 channels that are\nuncorrelated to each other. Note that unlike most /// other ImageBufAlgo\nfunctions, it does not return an ImageBuf by value, but /// by const reference.\nOIIO_API const ImageBuf& bluenoise_image(); /// Render a single point at (x,y)\nof the given color \"over\" the existing /// image `dst`. If there is no alpha\nchannel, the color will be written /// unconditionally (as if the alpha is 1.0).\nbool OIIO_API render_point (ImageBuf &dst, int x, int y, cspan color=1.0f, ROI\nroi={}, int nthreads=0); /// Render a line from pixel (`x1`,`y1`) to (`x2`,`y2`)\ninto `dst`, doing an /// \"over\" of the color (if it includes an alpha channel)\nonto the existing /// data in `dst`. The `color` should include as many values\nas /// `roi.chend-1`. The ROI can be used to limit the pixel area or channels\n/// that are modified, and default to the entirety of `dst`. If ///\n`skip_first_point` is `true`, the first point (`x1`, `y1`) will not be /// drawn\n(this can be helpful when drawing poly-lines, to avoid /// double-rendering of\nthe vertex positions). bool OIIO_API render_line (ImageBuf &dst, int x1, int y1,\nint x2, int y2, cspan color=1.0f, bool skip_first_point = false, ROI roi={}, int\nnthreads=0); /// Render a filled or unfilled box with corners at pixels\n(`x1`,`y1`) and /// (`x2`,`y2`) into `dst`, doing an \"over\" of the color (if it\nincludes an /// alpha channel) onto the existing data in `dst`. The `color` must\ninclude /// as many values as `roi.chend-1`. The ROI can be used to limit the\npixel /// area or channels that are modified, and default to the entirety of ///\n`dst`. If `fill` is `true`, the box will be completely filled in, /// otherwise\nonly its outline will be drawn. bool OIIO_API render_box (ImageBuf &dst, int x1,\nint y1, int x2, int y2, cspan color=1.0f, bool fill = false, ROI roi={}, int\nnthreads=0); enum class TextAlignX { Left, Right, Center }; enum class\nTextAlignY { Baseline, Top, Bottom, Center }; /// Render a text string (encoded\nas UTF-8) into image `dst`. If the `dst` /// image is not yet initialized, it\nwill be initialized to be a black /// background exactly large enough to contain\nthe rasterized text. If /// `dst` is already initialized, the text will be\nrendered into the /// existing image by essentially doing an \"over\" of the\ncharacter into the /// existing pixel data. /// /// @param dst /// Destination\nImageBuf -- text is rendered into this image. /// @param x/y /// The position to\nplace the text. /// @param text /// The text to draw. Linefeed (`\\n`) characters\nare respected /// as indications that the text spans multiple rows. /// @param\nfontsize/fontname /// Size and name of the font. If the name is not a full ///\npathname to a font file, it will search for a matching font, /// defaulting to\nsome reasonable system font if not supplied at /// all), and with a nominal\nheight of fontsize (in pixels). /// @param textcolor /// Color for drawing the\ntext, defaulting to opaque white /// (1.0,1.0,...) in all channels if not\nsupplied. If provided, /// it is expected to point to a float array of length at\nleast /// equal to `R.spec().nchannels`, or defaults will be chosen /// for\nyou). /// @param alignx/aligny /// The default behavior is to align the left\nedge of the /// character baseline to (`x`,`y`). Optionally, `alignx` and ///\n`aligny` can override the alignment behavior, with /// horizontal alignment\nchoices of TextAlignX::Left, Right, and /// Center, and vertical alignment\nchoices of Baseline, Top, /// Bottom, or Center. /// @param shadow /// If\nnonzero, a \"drop shadow\" of this radius will be used to /// make the text look\nmore clear by dilating the alpha channel /// of the composite (makes a black\nhalo around the characters). /// /// Note that any named fonts (if not a full\npathname) will search for the /// fonts in the following places: (a) any\ndirectories named in the global /// \"font_searchpath\" attribute or the\n`$OPENIMAGEIO_FONTS` environment /// variable; (b) any font-related\nsubdirectories (`fonts`, `Fonts`, /// `share/fonts`, or `Library/Fonts`)\nunderneath the directories in /// environment variables `$HOME`, `$SystemRoot`,\n`$OpenImageIO_ROOT`; (c) a /// number of common system font areas, including\n`/usr/share/fonts`, /// `/Library/fonts`, and `C:/Windows/fonts`; (d) in fonts\ndirectories one /// level up from the place where the currently running binary\nlives. bool OIIO_API render_text (ImageBuf &dst, int x, int y, string_view text,\nint fontsize=16, string_view fontname=\"\", cspan textcolor = 1.0f, TextAlignX\nalignx = TextAlignX::Left, TextAlignY aligny = TextAlignY::Baseline, int shadow\n= 0, ROI roi={}, int nthreads=0); /// The helper function `text_size()` merely\ncomputes the dimensions of the /// text, returning it as an ROI relative to the\nleft side of the baseline /// of the first character. Only the `x` and `y`\ndimensions of the ROI will /// be used. The x dimension runs from left to right,\nand y runs from top to /// bottom (image coordinates). For a failure (such as an\ninvalid font /// name), the ROI will return `false` if you call its `defined()`\nmethod. /// The `text` may contain linefeed characters to designate multiple\nlines /// of text. ROI OIIO_API text_size (string_view text, int fontsize=16,\nstring_view fontname=\"\"); /// Generic channel shuffling: return (or store in\n`dst`) a copy of `src`, /// but with channels in the order\n`channelorder[0..nchannels-1]` (or set to /// a constant value, designated by\n`channelorder[i] = -1` and having the /// fill value in `channelvalues[i]`.\nIn-place operation is allowed (i.e., /// `dst` and `src` the same image, but an\nextra copy will occur). /// /// @param nchannels /// The total number of\nchannels that will be set up in the /// `dst` image. /// @param channelorder ///\nFor each channel in `dst`, the index of the `src` channel /// from which to\ncopy. Any `channelorder[i]` < 0 indicates that /// the channel `i` should be\nfilled with constant value /// `channelvalues[i]` rather than copy any channel\nfrom `src`. /// If `channelorder` itself is empty, the implied channel order ///\nwill be `{0, 1, ..., nchannels-1}`, meaning that it's only /// renaming,\ntruncating, or extending channels, not reordering /// the channels that are\nalready present. /// @param channelvalues Fill values for color channels in\nwhich /// `channelorder[i]` < 0. This can be empty if no channels are /// to be\nfilled with constant values. /// @param newchannelnames /// An array of new\nchannel names. Channels for which this /// specifies an empty string will have\ntheir name taken from /// the `src` channel that was copied. If\n`newchannelnames` is /// entirely empty, all channel names will simply be copied\nfrom /// `src`. /// @param shuffle_channel_names /// If true, the channel names\nwill be taken from the /// corresponding channels of the source image -- be\ncareful with /// this, shuffling both channel ordering and their names could ///\nresult in no semantic change at all, if you catch the drift. /// If false (the\ndefault), the resulting `dst` image will have /// default channel names in the\nusual order (\"R\", \"G\", etc.). /// ImageBuf OIIO_API channels (const ImageBuf\n&src, int nchannels, cspan channelorder, cspan channelvalues={}, cspan\nnewchannelnames={}, bool shuffle_channel_names=false, int nthreads=0); /// Write\nto an existing image `dst` (allocating if it is uninitialized). bool OIIO_API\nchannels (ImageBuf &dst, const ImageBuf &src, int nchannels, cspan channelorder,\ncspan channelvalues={}, cspan newchannelnames={}, bool\nshuffle_channel_names=false, int nthreads=0); /// Append the channels of `A` and\n`B` together into `dst` over the region /// of interest. If the region passed is\nuninitialized (the default), it /// will be interpreted as being the union of\nthe pixel windows of `A` and `B` /// (and all channels of both images). If `dst`\nis not already initialized, /// it will be resized to be big enough for the\nregion. ImageBuf OIIO_API channel_append (const ImageBuf &A, const ImageBuf &B,\nROI roi={}, int nthreads=0); /// Write to an existing image `dst` (allocating if\nit is uninitialized). bool OIIO_API channel_append (ImageBuf &dst, const\nImageBuf &A, const ImageBuf &B, ROI roi={}, int nthreads=0); /// Return the\nspecified region of pixels of `src` as specified by `roi` /// (which will\ndefault to the whole of `src`, optionally with the pixel /// type overridden by\nconvert (if it is not `TypeUnknown`). ImageBuf OIIO_API copy (const ImageBuf\n&src, TypeDesc convert=TypeUnknown, ROI roi={}, int nthreads=0); /// Write to an\nexisting image `dst` (allocating if it is uninitialized). /// If `dst` is not\nalready initialized, it will be set to the same size as /// `roi` (defaulting to\nall of `src`) bool OIIO_API copy (ImageBuf &dst, const ImageBuf &src, TypeDesc\nconvert=TypeUnknown, ROI roi={}, int nthreads=0); /// Return the specified\nregion of `src` as an image, without altering its /// position in the image\nplane. /// /// Pixels from `src` which are outside `roi` will not be copied, and\nnew /// black pixels will be added for regions of `roi` which were outside the\n/// data window of `src`. /// /// Note that the `crop` operation does not\nactually move the pixels on the /// image plane or adjust the full/display\nwindow; it merely restricts which /// pixels are copied from `src` to `dst`.\n(Note the difference compared to /// `cut()`). ImageBuf OIIO_API crop (const\nImageBuf &src, ROI roi={}, int nthreads=0); /// Write to an existing image `dst`\n(allocating if it is uninitialized). bool OIIO_API crop (ImageBuf &dst, const\nImageBuf &src, ROI roi={}, int nthreads=0); /// Return the designated region of\n`src`, but repositioned to the image /// origin and with the full/display window\nset to exactly cover the new /// pixel data window. (Note the difference\ncompared to `crop()`). ImageBuf OIIO_API cut (const ImageBuf &src, ROI roi={},\nint nthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API cut (ImageBuf &dst, const ImageBuf &src, ROI\nroi={}, int nthreads=0); /// Copy `src` pixels within `srcroi` into the `dst`\nimage, offset so that /// source location (0,0,0) will be copied to destination\nlocation /// (`xbegin`,`ybegin`,`zbegin`). If the `srcroi` is `ROI::All()`, the\n/// entirety of the data window of `src` will be used. It will copy into ///\n`channels[chbegin...]`, as many channels as are described by srcroi. /// Pixels\nor channels of `src` inside `srcroi` will replace the /// corresponding\ndestination pixels entirely, whereas `src` pixels outside /// of `srcroi` will\nnot be copied and the corresponding offset pixels of /// `dst` will not be\naltered. bool OIIO_API paste (ImageBuf &dst, int xbegin, int ybegin, int zbegin,\nint chbegin, const ImageBuf &src, ROI srcroi={}, int nthreads=0); /// @defgroup\nrotateN (rotate in 90 degree increments) /// @{ /// /// Return (or copy into\n`dst`) a rotated copy of the image pixels of `src`, /// in 90 degree increments.\nPictorially: /// /// rotate90 rotate180 rotate270 /// ----------- -----------\n----------- /// AB --> CA AB --> DC AB --> BD /// CD DB CD BA CD AC /// ImageBuf\nOIIO_API rotate90 (const ImageBuf &src, ROI roi={}, int nthreads=0); ImageBuf\nOIIO_API rotate180 (const ImageBuf &src, ROI roi={}, int nthreads=0); ImageBuf\nOIIO_API rotate270 (const ImageBuf &src, ROI roi={}, int nthreads=0); bool\nOIIO_API rotate90 (ImageBuf &dst, const ImageBuf &src, ROI roi={}, int\nnthreads=0); bool OIIO_API rotate180 (ImageBuf &dst, const ImageBuf &src, ROI\nroi={}, int nthreads=0); bool OIIO_API rotate270 (ImageBuf &dst, const ImageBuf\n&src, ROI roi={}, int nthreads=0); /// @} /// @defgroup flip-flop-transpose\n(flip/flop/transpose: mirroring) /// @{ /// /// Return (or copy into `dst`) a\nsubregion of `src`, but with the scanlines /// exchanged vertically (flip), or\ncolumns exchanged horizontally (flop), /// or transposed across the diagonal by\nswapping rows for columns /// (transpose) within the display/full window. In\nother words, /// /// flip flop transpose /// ----------- ----------- -----------\n/// AB --> CD AB --> BA AB --> AC /// CD AB CD DC CD BD /// ImageBuf OIIO_API\nflip (const ImageBuf &src, ROI roi={}, int nthreads=0); ImageBuf OIIO_API flop\n(const ImageBuf &src, ROI roi={}, int nthreads=0); ImageBuf OIIO_API transpose\n(const ImageBuf &src, ROI roi={}, int nthreads=0); bool OIIO_API flip (ImageBuf\n&dst, const ImageBuf &src, ROI roi={}, int nthreads=0); bool OIIO_API flop\n(ImageBuf &dst, const ImageBuf &src, ROI roi={}, int nthreads=0); bool OIIO_API\ntranspose (ImageBuf &dst, const ImageBuf &src, ROI roi={}, int nthreads=0); ///\n@} /// Return (or store into `dst`) a copy of `src`, but with whatever series\n/// of rotations, flips, or flops are necessary to transform the pixels into ///\nthe configuration suggested by the \"Orientation\" metadata of the image /// (and\nthe \"Orientation\" metadata is then set to 1, ordinary orientation). ImageBuf\nOIIO_API reorient (const ImageBuf &src, int nthreads=0); /// Write to an\nexisting image `dst` (allocating if it is uninitialized). bool OIIO_API reorient\n(ImageBuf &dst, const ImageBuf &src, int nthreads=0); /// Return a subregion of\n`src`, but circularly shifting by the given /// amount. To clarify, the circular\nshift of [0,1,2,3,4,5] by +2 is /// [4,5,0,1,2,3]. ImageBuf OIIO_API\ncircular_shift (const ImageBuf &src, int xshift, int yshift, int zshift=0, ROI\nroi={}, int nthreads=0); /// Write to an existing image `dst` (allocating if it\nis uninitialized). bool OIIO_API circular_shift (ImageBuf &dst, const ImageBuf\n&src, int xshift, int yshift, int zshift=0, ROI roi={}, int nthreads=0); ///\n@defgroup rotate (rotate: arbitrary rotation) /// @{ /// /// Rotate the `src`\nimage by the `angle` (in radians, with positive angles /// clockwise). When\n`center_x` and `center_y` are supplied, they denote the /// center of rotation,\nin pixel coordinates; in their absence, the rotation /// will be about the\ncenter of the image's display window. /// /// Only the pixels (and channels) of\n`dst` that are specified by `roi` will /// be copied from the rotated `src`; the\ndefault `roi` is to alter all the /// pixels in `dst`. If `dst` is\nuninitialized, it will be resized to be an /// ImageBuf large enough to hold the\nrotated image if recompute_roi is /// true, or will have the same ROI as `src`\nif `recompute_roi` is `false`. /// It is an error to pass both an uninitialized\n`dst` and an undefined /// `roi`. /// /// The filter is used to weight the `src`\npixels falling underneath it for /// each `dst` pixel. The caller may specify a\nreconstruction filter by /// name and width (expressed in pixels units of the\n`dst` image), or /// `rotate()` will choose a reasonable default high-quality\ndefault filter /// (lanczos3) if the empty string is passed, and a reasonable\nfilter width /// if `filterwidth` is 0. (Note that some filter choices only make\nsense /// with particular width, in which case this filterwidth parameter may be\n/// ignored.) ImageBuf OIIO_API rotate (const ImageBuf &src, float angle,\nstring_view filtername = string_view(), float filterwidth = 0.0f, bool\nrecompute_roi = false, ROI roi={}, int nthreads=0); ImageBuf OIIO_API rotate\n(const ImageBuf &src, float angle, Filter2D *filter, bool recompute_roi = false,\nROI roi={}, int nthreads=0); ImageBuf OIIO_API rotate (const ImageBuf &src,\nfloat angle, float center_x, float center_y, string_view filtername =\nstring_view(), float filterwidth = 0.0f, bool recompute_roi = false, ROI roi={},\nint nthreads=0); ImageBuf OIIO_API rotate (const ImageBuf &src, float angle,\nfloat center_x, float center_y, Filter2D *filter, bool recompute_roi = false,\nROI roi={}, int nthreads=0); bool OIIO_API rotate (ImageBuf &dst, const ImageBuf\n&src, float angle, string_view filtername = string_view(), float filterwidth =\n0.0f, bool recompute_roi = false, ROI roi={}, int nthreads=0); bool OIIO_API\nrotate (ImageBuf &dst, const ImageBuf &src, float angle, Filter2D *filter, bool\nrecompute_roi = false, ROI roi={}, int nthreads=0); bool OIIO_API rotate\n(ImageBuf &dst, const ImageBuf &src, float angle, float center_x, float\ncenter_y, string_view filtername = string_view(), float filterwidth = 0.0f, bool\nrecompute_roi = false, ROI roi={}, int nthreads=0); bool OIIO_API rotate\n(ImageBuf &dst, const ImageBuf &src, float angle, float center_x, float\ncenter_y, Filter2D *filter, bool recompute_roi = false, ROI roi={}, int\nnthreads=0); /// @} /// @defgroup resize (resize: resize the image with nicely\nfiltered results) /// @{ /// /// Set `dst`, over the region of interest, to be a\nresized version of the /// corresponding portion of `src` (mapping such that the\n\"full\" image /// window of each correspond to each other, regardless of\nresolution). /// If `dst` is not yet initialized, it will be sized according to\n`roi`. /// /// The `options` list contains optional ParamValue's that control\nthe /// resizing behavior. The following options are recognized: /// /// -\n\"filtername\" : string (default: \"\") /// /// The type of reconstruction filter\nused to weight the `src` pixels /// falling underneath it for each `dst` pixel.\nIf the value is the /// empty string or not supplied, a reasonable high-quality\nfilter will /// be chosen automatically (blackman-harris when upsizing, lanczos3\n/// when downsizing). /// /// - \"filterwidth\" : float (default: 0) /// /// The\nwidth of the reconstruction filter, expressed in pixel units of /// the `dst`\nimage. If 0 or not supplied, the default width of the /// named filter will be\nused. /// /// - \"filterptr\" : pointer to a Filter2D (default: nullptr) /// ///\nAdvanced use: It is also possible to pass a custom reconstruction /// filter as\na `Filter2D*`, overriding any filtername and filterwidth /// that may also be\npassed. The easiest way to pass it is as: /// `make_pv(\"filterptr\",\nraw_filter_ptr)`. /// Use with caution! /// /// The caller may either (a)\nexplicitly pass a reconstruction `filter`, or /// (b) specify one by\n`filtername` and `filterwidth`. If `filter` is /// `nullptr` or if `filtername`\nis the empty string `resize()` will choose /// a reasonable high-quality default\n(blackman-harris when upsizing, /// lanczos3 when downsizing). The filter is\nused to weight the `src` /// pixels falling underneath it for each `dst` pixel;\nthe filter's size is /// expressed in pixel units of the `dst` image. ImageBuf\nOIIO_API resize(const ImageBuf &src, KWArgs options = {}, ROI roi = {}, int\nnthreads = 0); bool OIIO_API resize(ImageBuf &dst, const ImageBuf &src, KWArgs\noptions = {}, ROI roi = {}, int nthreads=0); /// @} /// Set `dst`, over the\nregion of interest, to be a resized version of the /// corresponding portion of\n`src` (mapping such that the \"full\" image /// window of each correspond to each\nother, regardless of resolution). If /// `dst` is not yet initialized, it will\nbe sized according to `roi`. /// /// Unlike `ImageBufAlgo::resize()`,\n`resample()` does not take a filter; it /// just samples either with a bilinear\ninterpolation (if `interpolate` is /// `true`, the default) or uses the single\n\"closest\" pixel (if /// `interpolate` is `false`). This makes it a lot faster\nthan a proper /// `resize()`, though obviously with lower quality (aliasing when\n/// downsizing, pixel replication when upsizing). /// /// For \"deep\" images,\nthis function returns copies the closest source pixel /// needed, rather than\nattempting to interpolate deep pixels (regardless of /// the value of\n`interpolate`). /// /// @see ImageBufAlgo::resize() ImageBuf OIIO_API resample\n(const ImageBuf &src, bool interpolate = true, ROI roi={}, int nthreads=0); ///\nWrite to an existing image `dst` (allocating if it is uninitialized). bool\nOIIO_API resample (ImageBuf &dst, const ImageBuf &src, bool interpolate = true,\nROI roi={}, int nthreads=0); /// @defgroup fit (fit: resize the image with\nfiltering, into a fixed size) /// @{ /// /// Resize `src` to fit into `dst` (to\na size specified by `roi`, if `dst` is /// not initialized), preserving its\noriginal aspect ratio. Thus, it will /// resize to be the largest size with the\nsame aspect ratio that can fit /// inside the region, but will not necessarily\ncompletely fill it in both /// dimensions if the source and destination image\nbuffers do not have the /// same aspect ratio. /// /// The `options` list\ncontains optional ParamValue's that control the /// resizing behavior. The\nfollowing options are recognized: /// /// - \"filtername\" : string (default: \"\")\n/// /// The type of reconstruction filter used to weight the `src` pixels ///\nfalling underneath it for each `dst` pixel. If the value is the /// empty string\nor not supplied, a reasonable high-quality filter will /// be chosen\nautomatically (blackman-harris when upsizing, lanczos3 /// when downsizing). ///\n/// - \"filterwidth\" : float (default: 0) /// /// The width of the reconstruction\nfilter, expressed in pixel units of /// the `dst` image. If 0 or not supplied,\nthe default width of the /// named filter will be used. /// /// - \"filterptr\" :\npointer to a Filter2D (default: nullptr) /// /// Advanced use: It is also\npossible to pass a custom reconstruction /// filter as a `Filter2D*`, overriding\nany filtername and filterwidth /// that may also be passed. The easiest way to\npass it is as: /// `make_pv(\"filterptr\", raw_filter_ptr)`. /// Use with caution!\n/// /// - \"fillmode\" : string (default: \"letterbox\") /// /// The `fillmode`\ndetermines which of several methods will be used to /// determine how the image\nwill fill the new frame, if its aspect ratio /// does not precisely match the\noriginal source aspect ratio: /// /// - \"width\" exactly fills the width of the\nnew frame, either cropping /// or letterboxing the height if it isn't precisely\nthe right size /// to preserve the original aspect ratio. /// - \"height\" exactly\nfills the height of the new frame, either /// cropping or letterboxing the width\nif it isn't precisely the /// right size to preserve the original aspect ratio.\n/// - \"letterbox\" (the default) chooses whichever of \"width\" or /// \"height\"\nwill maximally fill the new frame with no image data /// lost (it will only\nletterbox, never crop). /// /// - \"exact\" : int (default: 0) /// /// If nonzero,\nwill result in an exact match on aspect ratio and /// centering (partial pixel\nshift if necessary), whereas exact=false /// will only preserve aspect ratio and\ncentering to the precision of a /// whole pixel. /// ImageBuf OIIO_API fit(const\nImageBuf &src, KWArgs options = {}, ROI roi={}, int nthreads=0); bool OIIO_API\nfit(ImageBuf &dst, const ImageBuf &src, KWArgs options = {}, ROI roi={}, int\nnthreads=0); /// @} /// @defgroup warp (warp: arbitrary warp by a 3x3 matrix)\n/// @{ /// /// Warp the `src` image using the supplied 3x3 transformation\nmatrix. /// /// Only the pixels (and channels) of `dst` that are specified by\n`roi` will /// be copied from the warped `src`; the default is to alter all the\npixels in /// `dst`. If `dst` is uninitialized, it will be sized to be an\nImageBuf large /// enough to hold the warped image if recompute_roi is true, or\nwill have the /// same ROI as src if recompute_roi is false. It is an error to\npass both an /// uninitialized `dst` and an undefined `roi`. /// /// @param dst\n/// The output ImageBuf. If not already initialized, it will be sized /// based\non `roi` (which itself will default to the size of `src`, /// if not specified).\n/// @param src /// The source ImageBuf. /// @param M /// A 3x3 matrix describing\nthe desired spatial transformation /// of destination pixel coordinates to\nsource pixel coordinates. /// @param roi /// The region of `dst` that will\nreceive transformed pixels. If /// not specified, it will be all the pixels of\n`dst`. /// @param options /// Optional ParamValue's that may control the\nfiltering and /// reconstruction. /// /// The `options` list contains optional\nParamValue's that may control the /// filtering and reconstruction. The\nfollowing options are recognized: /// /// - \"filtername\" : string (default: \"\")\n/// /// The type of reconstruction filter used to weight the `src` pixels ///\nfalling underneath it for each `dst` pixel. If the value is the /// empty string\nor not supplied, a reasonable high-quality filter will /// be chosen\nautomatically. /// /// - \"filterwidth\" : float (default: 0) /// /// The width of\nthe reconstruction filter, expressed in pixel units of /// the `dst` image. If 0\nor not supplied, the default width of the /// named filter will be used. /// ///\n- \"wrap\" : string (default: \"black\") /// /// The wrap mode controlling the value\nof pixel lookups that need to /// occur beyond the boundary of the `src` image.\n(Could be one of: /// black, clamp, periodic, mirror.) /// /// - \"edgeclamp\" :\nint (default: 0) /// /// If nonzero, will enable special edge clamp behavior to\nreduce /// artifacts at the image edges (experimental). /// /// -\n\"recompute_roi\" : int (default: 0) /// /// If nonzero and `dst` is not yet\ninitialized, the result image /// will be sized to be large enough to hold the\nwarped image. If /// zero (the default), the `dst` image will have the same ROI\nas /// `src`. If the `dst` image already is initialized, its size will /// not\nbe changed and this option will be ignored. /// /// - \"filterptr\" : pointer to a\nFilter2D (default: nullptr) /// /// Advanced use: It is also possible to pass a\ncustom reconstruction /// filter as a `Filter2D*`, overriding any filtername and\nfilterwidth /// that may also be passed. The easiest way to pass it is as: ///\n`make_pv(\"filterptr\", raw_filter_ptr)`. /// Use with caution! /// ImageBuf\nOIIO_API warp(const ImageBuf &src, M33fParam M, KWArgs options = {}, ROI roi =\n{}, int nthreads = 0); bool OIIO_API warp(ImageBuf &dst, const ImageBuf &src,\nM33fParam M, KWArgs options = {}, ROI roi = {}, int nthreads = 0); /// @} ///\n@defgroup st_warp (st_warp: warp an image using per-pixel st coordinates) /// @{\n/// /// Warp the `src` image using \"st\" coordinates from a secondary `stbuf`\nimage. /// /// Each pixel in the `stbuf` image is used as a normalized\nimage-space /// coordinate in the `src` image, which is then sampled at that\nposition using /// the given reconstruction filter to produce an output pixel.\n/// /// The transform is only defined over the area of the `stbuf` image, and\nthus /// the given `roi` argument will be intersected with its geometry. /// ///\n\\b NOTE: The current behavior of this transform is modeled to match Nuke's ///\nSTMap node. /// /// @param dst /// The output ImageBuf. If an initialized buffer\nis provided, its /// full-size dimensions must match those of `stbuf`. ///\n@param src /// The source ImageBuf to warp. /// @param stbuf /// The ImageBuf\nholding the st coordinates. This must be holding /// a floating-point pixel data\ntype. /// @param chan_s /// The index of the \"s\" channel in the `stbuf` image.\nThis defaults /// to its first channel. /// @param chan_t /// The index of the\n\"t\" channel in the `stbuf` image. This defaults /// to its second channel. ///\n@param flip_s /// Whether to mirror the \"s\" coordinate along the horizontal axis\n/// when computing source pixel positions. This is useful if the /// coordinates\nare defined in terms of a different image origin /// than OpenImageIO's. ///\n@param flip_t /// Whether to mirror the \"t\" coordinate along the vertical axis\n/// when computing source pixel positions. This is useful if the /// coordinates\nare defined in terms of a different image origin /// than OpenImageIO's.\nImageBuf OIIO_API st_warp (const ImageBuf &src, const ImageBuf& stbuf,\nstring_view filtername=string_view(), float filterwidth=0.0f, int chan_s=0, int\nchan_t=1, bool flip_s=false, bool flip_t=false, ROI roi={}, int nthreads=0);\nImageBuf OIIO_API st_warp (const ImageBuf &src, const ImageBuf& stbuf, const\nFilter2D *filter, int chan_s=0, int chan_t=1, bool flip_s=false, bool\nflip_t=false, ROI roi={}, int nthreads=0); bool OIIO_API st_warp (ImageBuf &dst,\nconst ImageBuf &src, const ImageBuf& stbuf, string_view\nfiltername=string_view(), float filterwidth=0.0f, int chan_s=0, int chan_t=1,\nbool flip_s=false, bool flip_t=false, ROI roi={}, int nthreads=0); bool OIIO_API\nst_warp (ImageBuf &dst, const ImageBuf &src, const ImageBuf& stbuf, const\nFilter2D *filter, int chan_s=0, int chan_t=1, bool flip_s=false, bool\nflip_t=false, ROI roi={}, int nthreads=0); /// @} /// Compute per-pixel sum `A +\nB`, returning the result image. /// /// `A` and `B` may each either be an\n`ImageBuf&`, or a `cspan` /// giving a per- channel constant, or a single\nconstant used for all /// channels. (But at least one must be an image.)\nImageBuf OIIO_API add (Image_or_Const A, Image_or_Const B, ROI roi={}, int\nnthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API add (ImageBuf &dst, Image_or_Const A,\nImage_or_Const B, ROI roi={}, int nthreads=0); /// Compute per-pixel signed\ndifference `A - B`, returning the result image. /// /// `A` and `B` may each\neither be an `ImageBuf&`, or a `cspan` /// giving a per-channel constant, or a\nsingle constant used for all /// channels. (But at least one must be an image.)\nImageBuf OIIO_API sub (Image_or_Const A, Image_or_Const B, ROI roi={}, int\nnthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API sub (ImageBuf &dst, Image_or_Const A,\nImage_or_Const B, ROI roi={}, int nthreads=0); /// Compute per-pixel absolute\ndifference `abs(A - B)`, returning the result /// image. /// /// `A` and `B` may\neach either be an `ImageBuf&`, or a `cspan` /// giving a per- channel constant,\nor a single constant used for all /// channels. (But at least one must be an\nimage.) ImageBuf OIIO_API absdiff (Image_or_Const A, Image_or_Const B, ROI\nroi={}, int nthreads=0); /// Write to an existing image `dst` (allocating if it\nis uninitialized). bool OIIO_API absdiff (ImageBuf &dst, Image_or_Const A,\nImage_or_Const B, ROI roi={}, int nthreads=0); /// Compute per-pixel absolute\nvalue `abs(A)`, returning the result image. ImageBuf OIIO_API abs (const\nImageBuf &A, ROI roi={}, int nthreads=0); /// Write to an existing image `dst`\n(allocating if it is uninitialized). bool OIIO_API abs (ImageBuf &dst, const\nImageBuf &A, ROI roi={}, int nthreads=0); /// Compute per-pixel product `A * B`,\nreturning the result image. At least /// one of `A` and `B` must be a single\nchannel image, whose value is used to /// scale all channels of the other image.\n/// /// @param options /// Optional ParamValue's that may control the\nreconstruction. /// (Reserved for future expansion.) /// ImageBuf OIIO_API scale\n(const ImageBuf &A, const ImageBuf &B, KWArgs options = {}, ROI roi={}, int\nnthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API scale (ImageBuf &dst, const ImageBuf &A, const\nImageBuf &B, KWArgs options = {}, ROI roi={}, int nthreads=0); /// Compute\nper-pixel product `A * B`, returning the result image. /// /// Either both `A`\nand `B` are images, or one is an image and the other is /// a `cspan` giving a\nper-channel constant or a single constant /// used for all channels. ImageBuf\nOIIO_API mul (Image_or_Const A, Image_or_Const B, ROI roi={}, int nthreads=0);\n/// Write to an existing image `dst` (allocating if it is uninitialized). bool\nOIIO_API mul (ImageBuf &dst, Image_or_Const A, Image_or_Const B, ROI roi={}, int\nnthreads=0); /// Compute per-pixel division `A / B`, returning the result image.\n/// Division by zero is defined to result in zero. /// /// `A` is always an\nimage, and `B` is either an image or a `cspan` /// giving a per-channel constant\nor a single constant used for all /// channels. ImageBuf OIIO_API div\n(Image_or_Const A, Image_or_Const B, ROI roi={}, int nthreads=0); /// Write to\nan existing image `dst` (allocating if it is uninitialized). bool OIIO_API div\n(ImageBuf &dst, Image_or_Const A, Image_or_Const B, ROI roi={}, int nthreads=0);\n/// Compute per-pixel multiply-and-add `A * B + C`, returning the result ///\nimage. /// /// `A`, `B`, and `C` are each either an image, or a `cspan` giving a\n/// per-channel constant or a single constant used for all channels. (Note: ///\nat least one must be an image.) ImageBuf OIIO_API mad (Image_or_Const A,\nImage_or_Const B, Image_or_Const C, ROI roi={}, int nthreads=0); /// Write to an\nexisting image `dst` (allocating if it is uninitialized). bool OIIO_API mad\n(ImageBuf &dst, Image_or_Const A, Image_or_Const B, Image_or_Const C, ROI\nroi={}, int nthreads=0); /// Return the composite of `A` over `B` using the\nPorter/Duff definition of /// \"over\", returning true upon success and false for\nany of a variety of /// failures (as described below). /// /// `A` and `B` (and\ndst, if already defined/allocated) must have valid /// alpha channels identified\nby their ImageSpec `alpha_channel` field. If` /// A` or `B` do not have alpha\nchannels (as determined by those rules) or /// if the number of non-alpha\nchannels do not match between `A` and `B`, /// `over()` will fail, returning\nfalse. /// /// If `dst` is not already an initialized ImageBuf, it will be sized\nto /// encompass the minimal rectangular pixel region containing the union of\n/// the defined pixels of `A` and `B`, and with a number of channels equal ///\nto the number of non-alpha channels of `A` and `B`, plus an alpha /// channel.\nHowever, if `dst` is already initialized, it will not be /// resized, and the\n\"over\" operation will apply to its existing pixel data /// window. In this case,\ndst must have an alpha channel designated and /// must have the same number of\nnon-alpha channels as `A` and `B`, /// otherwise it will fail, returning false.\n/// /// `A`, `B`, and `dst` need not perfectly overlap in their pixel data ///\nwindows; pixel values of `A` or `B` that are outside their respective /// pixel\ndata window will be treated as having \"zero\" (0,0,0...) value. ImageBuf OIIO_API\nover (const ImageBuf &A, const ImageBuf &B, ROI roi={}, int nthreads=0); ///\nWrite to an existing image `dst` (allocating if it is uninitialized). bool\nOIIO_API over (ImageBuf &dst, const ImageBuf &A, const ImageBuf &B, ROI roi={},\nint nthreads=0); /// Just like `ImageBufAlgo::over()`, but inputs `A` and `B`\nmust have /// designated 'z' channels, and on a pixel-by-pixel basis, the z\nvalues /// will determine which of `A` or `B` will be considered the foreground\nor /// background (lower z is foreground). If `z_zeroisinf` is true, then z=0\n/// values will be treated as if they are infinitely far away. ImageBuf OIIO_API\nzover (const ImageBuf &A, const ImageBuf &B, bool z_zeroisinf=false, ROI roi={},\nint nthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API zover (ImageBuf &dst, const ImageBuf &A, const\nImageBuf &B, bool z_zeroisinf=false, ROI roi={}, int nthreads=0); /// Compute\nper-pixel value inverse `1.0 - A` (which you can think of as /// roughly meaning\nswitching white and black), returning the result image. /// /// Tips for\ncallers: (1) You probably want to set `roi` to restrict the /// operation to\nonly the color channels, and not accidentally include /// alpha, z, or others.\n(2) There may be situations where you want to /// `unpremult()` before the\ninvert, then `premult()` the result, so that /// you are computing the inverse\nof the unmasked color. ImageBuf OIIO_API invert (const ImageBuf &A, ROI roi={},\nint nthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API invert (ImageBuf &dst, const ImageBuf &A, ROI\nroi={}, int nthreads=0); /// Compute per-pixel raise-to-power `A ^ B`. returning\nthe result image. It /// is permitted for `dst` and `A` to be the same image.\n/// /// `A` is always an image, and `B` is either an image or a `cspan` ///\ngiving a per-channel constant or a single constant used for all /// channels.\nImageBuf OIIO_API pow (const ImageBuf &A, cspan B, ROI roi={}, int nthreads=0);\n/// Write to an existing image `dst` (allocating if it is uninitialized). bool\nOIIO_API pow (ImageBuf &dst, const ImageBuf &A, cspan B, ROI roi={}, int\nnthreads=0); /// Normalize a 3D vector texture (i.e., divide each pixel by its\nlength). /// This function assumes a 3-channel image that represents a 3-vector,\nor a /// 4-channel image that represents a 3-vector plus an alpha value. If an\n/// alpha channel is present, its value is merely copied, and is not part of ///\nthe normalization computation. If the destination has no alpha channel but ///\nthe sources do, the alpha channel will be dropped. /// /// `inCenter` and\n`outCenter` define the pixel value that corresponds to a /// 0.0 vector value\nfor input and output, respectively. `scale` defines the /// scale factor to\napply to the normalized vectors. /// /// Thus, if the input image encodes vector\ncomponents into [0,1] range pixel /// values so that a pixel value 0.5 indicates\na 0-length vector, then you /// should use `inCenter=0.5`, whereas if they are\nalready using the full /// range (0.0 is encoded as 0.0), then you want\n`inCenter=0.0`. Similarly, if /// you want the output normalized vectors to be\nin the range [0,1], use /// `outCenter=0.5` and `scale=0.5`, but if you want\nthem to be in the range /// [-1,1], use `outCenter=0.0` and `scale=1.0` (this\nprobably will only work /// if you intend to write the results in `float` or\n`half` format). /// /// Expressed another way, the computation is conceptually:\n/// /// out = outCenter + scale * (in - inCenter) / length(in - inCenter) ///\nbool OIIO_API normalize(ImageBuf& dst, const ImageBuf& A, float inCenter=0.0f,\nfloat outCenter=0.0f, float scale=1.0f, ROI roi={}, int nthreads=0); ImageBuf\nOIIO_API normalize(const ImageBuf& A, float inCenter=0.0f, float outCenter=0.0,\nfloat scale=1.0f, ROI roi={}, int nthreads=0); /// Converts a multi-channel\nimage into a one-channel image via a weighted /// sum of channels: /// ///\n(channel[0]*weight[0] + channel[1]*weight[1] + ...) /// /// returning the\nresulting one-channel image. The `weights`, if not /// supplied, default to `{\n1, 1, 1, ... }`). ImageBuf OIIO_API channel_sum (const ImageBuf &src, cspan\nweights=1.0f, ROI roi={}, int nthreads=0); /// Write to an existing image `dst`\n(allocating if it is uninitialized). bool OIIO_API channel_sum (ImageBuf &dst,\nconst ImageBuf &src, cspan weights=1.0f, ROI roi={}, int nthreads=0); ///\n@defgroup maxminclamp (Maximum, minimum, clamping) /// @{ /// /// `max()` and\n`min()` take the pixel-by-pixel, channel-by-channel /// maximum and minimum of\ntwo images, or of an image and a constant. /// /// `clamp()` restricts values of\nan image to the range between per-channel /// minimum and maximum constant\nvalues. /// Compute per-pixel `max(A, B)`, returning the result image. /// ///\nEither both `A` and `B` are images, or one is an image and the other is /// a\n`cspan` giving a per-channel constant or a single constant /// used for all\nchannels. ImageBuf OIIO_API max (Image_or_Const A, Image_or_Const B, ROI roi={},\nint nthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API max (ImageBuf &dst, Image_or_Const A,\nImage_or_Const B, ROI roi={}, int nthreads=0); /// Compute per-pixel `min(A,\nB)`, returning the result image. /// /// Either both `A` and `B` are images, or\none is an image and the other is /// a `cspan` giving a per-channel constant or\na single constant /// used for all channels. ImageBuf OIIO_API min\n(Image_or_Const A, Image_or_Const B, ROI roi={}, int nthreads=0); /// Write to\nan existing image `dst` (allocating if it is uninitialized). bool OIIO_API min\n(ImageBuf &dst, Image_or_Const A, Image_or_Const B, ROI roi={}, int nthreads=0);\n/// Return pixels of `src` with pixel values clamped as follows: /// @param min\n/// The minimum clamp value for each channel. If `min` is /// empty, no minimum\nclamping is performed. /// @param max /// The maximum clamp value for each\nchannel. If `max` is /// empty, no maximum clamping is performed. /// @param\nclampalpha01 /// If true, then additionally any alpha channel is clamped /// to\nthe 0-1 range. ImageBuf OIIO_API clamp (const ImageBuf &src, cspan\nmin=-std::numeric_limits::max(), cspan max=std::numeric_limits::max(), bool\nclampalpha01 = false, ROI roi={}, int nthreads=0); /// Write to an existing\nimage `dst` (allocating if it is uninitialized). bool OIIO_API clamp (ImageBuf\n&dst, const ImageBuf &src, cspan min=-std::numeric_limits::max(), cspan\nmax=std::numeric_limits::max(), bool clampalpha01 = false, ROI roi={}, int\nnthreads=0); /// @} /// @defgroup maxminchan (Maximum / minimum of channels) ///\n@{ /// /// `maxchan()` computes a one-channel image that for each pixel,\ncontains the /// maximum value of all channels of corresponding pixel of the\nsource image. /// `minchan()` similarly computes the minimum value of all\nchannels. /// /// @version 2.3.10 ImageBuf OIIO_API maxchan (const ImageBuf& A,\nROI roi={}, int nthreads=0); bool OIIO_API maxchan (ImageBuf &dst, const\nImageBuf& A, ROI roi={}, int nthreads=0); ImageBuf OIIO_API minchan (const\nImageBuf& src, ROI roi={}, int nthreads=0); bool OIIO_API minchan (ImageBuf\n&dst, const ImageBuf& src, ROI roi={}, int nthreads=0); /// @} /// Return pixel\nvalues that are a contrast-remap of the corresponding /// values of the `src`\nimage, transforming pixel value domain [black, /// white] to range [min, max],\neither linearly or with optional application /// of a smooth sigmoidal remapping\n(if `scontrast` != 1.0). /// /// The following steps are performed, in order:\n/// /// 1. Linearly rescale values [`black`, `white`] to [0, 1]. /// 2. If\n`scontrast` != 1, apply a sigmoidal remapping where a larger /// `scontrast`\nvalue makes a steeper slope, and the steepest part is at /// value `sthresh`\n(relative to the new remapped value after steps 1 & /// 2; the default is 0.5).\n/// 3. Rescale the range of that result: 0.0 -> `min` and 1.0 -> `max`. /// ///\nValues outside of the [black,white] range will be extrapolated to /// outside\n[min,max], so it may be prudent to apply a clamp() to the /// results. /// ///\nThe black, white, min, max, scontrast, sthresh parameters may each /// either be\na single float value for all channels, or a span giving /// per-channel values.\n/// /// You can use this function for a simple linear contrast remapping of ///\n[black, white] to [min, max] if you use the default values for sthresh. /// Or\njust a simple sigmoidal contrast stretch within the [0,1] range if /// you leave\nall other parameters at their defaults, or a combination of /// these effects.\nNote that if `black` == `white`, the result will be a /// simple binary\nthresholding where values < `black` map to `min` and /// values >= `black` map\nto `max`. OIIO_API ImageBuf contrast_remap (const ImageBuf &src, cspan\nblack=0.0f, cspan white=1.0f, cspan min=0.0f, cspan max=1.0f, cspan\nscontrast=1.0f, cspan sthresh=0.5f, ROI={}, int nthreads=0); /// Write to an\nexisting image `dst` (allocating if it is uninitialized). OIIO_API bool\ncontrast_remap (ImageBuf &dst, const ImageBuf &src, cspan black=0.0f, cspan\nwhite=1.0f, cspan min=0.0f, cspan max=1.0f, cspan scontrast=1.0f, cspan\nsthresh=0.5f, ROI={}, int nthreads=0); /// @defgroup saturate (Adjust saturation\nof color channels) /// @{ /// /// Increase or decrease color saturation of the\nimage. /// /// The `saturate` operation returns (or copies into `dst`) the\npixels of /// `src` within the ROI, and in the process adjusts the color\nsaturation of /// the three consecutive channels starting with `firstchannel`\nbased on the /// `scale` parameter: 0.0 fully desaturates to a greyscale image\nof /// perceptually equivalent luminance, 1.0 leaves the colors unchanged, ///\n`scale` values inside this range interpolate between them, and `scale` > 1 ///\nwould increase apparent color saturation. /// /// Channels that are within the\nrange of `roi.chbegin` to `roi.chend-1`, but /// outside the range of\n`firstchannel` to `firstchannel+2` are simply copied /// unaltered. Only three\nchannels at a time can be desaturated, by default /// the first three channels,\nthough `firstchannel` may be used to specify a /// different subset of channels.\nIt is allowed for `src` and `dst` to be the /// same image. /// /// @version\n2.4+ ImageBuf OIIO_API saturate (const ImageBuf &src, float scale = 0.0f, int\nfirstchannel = 0, ROI roi={}, int nthreads=0); bool OIIO_API saturate (ImageBuf\n&dst, const ImageBuf &src, float scale = 0.0f, int firstchannel = 0, ROI roi={},\nint nthreads=0); /// @} /// @defgroup color_map (Remap value range by spline or\nname) /// @{ /// /// Remap value range by spline or name /// /// Return (or copy\ninto `dst`) pixel values determined by looking up a /// color map using values\nof the source image, using either the channel /// specified by `srcchannel`, or\nthe luminance of `src`'s RGB if /// `srcchannel` is -1. This happens for all\npixels within the ROI (which /// defaults to all of `src`), and if `dst` is not\nalready initialized, it /// will be initialized to the ROI and with color\nchannels equal to /// `channels`. /// /// In the variant that takes a `knots`\nparameter, this specifies the values /// of a linearly-interpolated color map\ngiven by `knots[nknots*channels]`. /// An input value of 0.0 is mapped to\n`knots[0..channels-1]` (one value for /// each color channel), and an input\nvalue of 1.0 is mapped to /// `knots[(nknots-1)*channels..knots.size()-1]`. ///\n/// In the variant that takes a `mapname` parameter, this is the name of a ///\ncolor map. Recognized map names include: \"inferno\", \"viridis\", \"magma\", ///\n\"plasma\", all of which are perceptually uniform, strictly increasing in ///\nluminance, look good when converted to grayscale, and work for people /// with\nall types of colorblindness. Also \"turbo\" has most of these /// properties\n(except for being strictly increasing in luminance) and /// is a nice\nrainbow-like pattern. Also supported are the following color /// maps that do\nnot have those desirable qualities (and are thus not /// recommended, but are\npresent for back-compatibility or for use by /// clueless people): \"blue-red\",\n\"spectrum\", and \"heat\". In all cases, the /// implied `channels` is 3. ImageBuf\nOIIO_API color_map (const ImageBuf &src, int srcchannel, int nknots, int\nchannels, cspan knots, ROI roi={}, int nthreads=0); ImageBuf OIIO_API color_map\n(const ImageBuf &src, int srcchannel, string_view mapname, ROI roi={}, int\nnthreads=0); bool OIIO_API color_map (ImageBuf &dst, const ImageBuf &src, int\nsrcchannel, int nknots, int channels, cspan knots, ROI roi={}, int nthreads=0);\nbool OIIO_API color_map (ImageBuf &dst, const ImageBuf &src, int srcchannel,\nstring_view mapname, ROI roi={}, int nthreads=0); /// @} /// @defgroup range\n(Nonlinear range remapping for contrast preservation) /// @{ /// /// Nonlinear\nrange remapping for contrast preservation /// /// `rangecompress()` returns (or\ncopy into `dst`) all pixels and color /// channels of `src` within region `roi`\n(defaulting to all the defined /// pixels of `dst`), rescaling their range with\na logarithmic /// transformation. Alpha and z channels are not transformed. ///\n/// `rangeexpand()` performs the inverse transformation (logarithmic back ///\ninto linear). /// /// If `useluma` is true, the luma of channels\n[roi.chbegin..roi.chbegin+2] /// (presumed to be R, G, and B) are used to\ncompute a single scale factor /// for all color channels, rather than scaling\nall channels individually /// (which could result in a color shift). /// /// The\npurpose of these function is as follows: Some image operations (such /// as\nresizing with a \"good\" filter that contains negative lobes) can have ///\nobjectionable artifacts when applied to images with very high-contrast ///\nregions involving extra bright pixels (such as highlights in HDR /// captured or\nrendered images). By compressing the range pixel values, /// then performing the\noperation, then expanding the range of the result /// again, the result can be\nmuch more pleasing (even if not exactly /// correct). ImageBuf OIIO_API\nrangecompress (const ImageBuf &src, bool useluma = false, ROI roi={}, int\nnthreads=0); ImageBuf OIIO_API rangeexpand (const ImageBuf &src, bool useluma =\nfalse, ROI roi={}, int nthreads=0); bool OIIO_API rangecompress (ImageBuf &dst,\nconst ImageBuf &src, bool useluma = false, ROI roi={}, int nthreads=0); bool\nOIIO_API rangeexpand (ImageBuf &dst, const ImageBuf &src, bool useluma = false,\nROI roi={}, int nthreads=0); /// @} struct OIIO_API PixelStats { std::vector\nmin; std::vector max; std::vector avg; std::vector stddev; std::vector nancount;\nstd::vector infcount; std::vector finitecount; std::vector sum, sum2; // for\nintermediate calculation PixelStats () {} PixelStats (PixelStats&& other) =\ndefault; PixelStats (int nchannels) { reset(nchannels); } void reset (int\nnchannels); void merge (const PixelStats &p); const PixelStats& operator=\n(PixelStats&& other); // Move assignment }; /// Compute statistics about the ROI\nof the `src` image, returning a /// PixelStats structure. Upon success, the\nreturned vectors in the result /// structure will have size == src.nchannels().\nIf there is a failure, the /// vector sizes will be 0 and an error will be set\nin src. PixelStats OIIO_API computePixelStats (const ImageBuf &src, ROI roi={},\nint nthreads=0); // Struct holding all the results computed by\nImageBufAlgo::compare(). // (maxx,maxy,maxz,maxc) gives the pixel coordinates\n(x,y,z) and color // channel of the pixel that differed maximally between the\ntwo images. // nwarn and nfail are the number of \"warnings\" and \"failures\", //\nrespectively. struct CompareResults { double meanerror, rms_error, PSNR,\nmaxerror; int maxx, maxy, maxz, maxc; imagesize_t nwarn, nfail; bool error; };\n/// Numerically compare two images. The difference threshold (for any ///\nindividual color channel in any pixel) for a \"failure\" is `failthresh`, /// and\nfor a \"warning\" is `warnthresh`. If nonzero, then `failrelative` and ///\n`warnrelative` are alternate thresholds as a portion the mean of the ///\nabsolute values of the two images. It only warns or fails if both criteria ///\nare met. More formally, a value comparison will fail if /// /// abs(A-B) >\nfailthresh && abs(A-B)/((abs(A)+abs(B))/2) > failrelative /// /// and\nanalogously for warning. /// /// The results are stored in `result`. If `roi` is\ndefined, pixels will be /// compared for the pixel and channel range that is\nspecified. If `roi` is /// not defined, the comparison will be for all channels,\non the union of the /// defined pixel windows of the two images (for either\nimage, undefined /// pixels will be assumed to be black). CompareResults\nOIIO_API compare (const ImageBuf &A, const ImageBuf &B, float failthresh, float\nwarnthresh, float failrelative, float warnrelative, ROI roi={}, int nthreads=0);\n/// Numerically compare two images. The difference threshold (for any ///\nindividual color channel in any pixel) for a \"failure\" is /// failthresh, and\nfor a \"warning\" is warnthresh. The results are /// stored in result. If roi is\ndefined, pixels will be compared for /// the pixel and channel range that is\nspecified. If roi is not /// defined, the comparison will be for all channels,\non the union of /// the defined pixel windows of the two images (for either\nimage, /// undefined pixels will be assumed to be black). CompareResults\nOIIO_API compare (const ImageBuf &A, const ImageBuf &B, float failthresh, float\nwarnthresh, ROI roi={}, int nthreads=0); /// Compare two images using Hector\nYee's perceptual metric, returning /// the number of pixels that fail the\ncomparison. Only the first three /// channels (or first three channels specified\nby `roi`) are compared. /// Free parameters are the ambient luminance in the\nroom and the field /// of view of the image display; our defaults are probably\nreasonable /// guesses for an office environment. The 'result' structure will\n/// store the maxerror, and the maxx, maxy, maxz of the pixel that /// failed\nmost severely. (The other fields of the CompareResults /// are not used for Yee\ncomparison.) /// /// Works for all pixel types. But it's basically meaningless\nif the /// first three channels aren't RGB in a linear color space that sort ///\nof resembles AdobeRGB. /// /// Return true on success, false on error. int\nOIIO_API compare_Yee (const ImageBuf &A, const ImageBuf &B, CompareResults\n&result, float luminance = 100, float fov = 45, ROI roi={}, int nthreads=0); ///\nDo all pixels within the ROI have the same values for channels ///\n`[roi.chbegin..roi.chend-1]`, within a tolerance of +/- `threshold`? If /// so,\nreturn `true` and store that color in `color[chbegin...chend-1]` (if /// `color`\nis not empty); otherwise return `false`. If `roi` is not /// defined (the\ndefault), it will be understood to be all of the defined /// pixels and channels\nof source. OIIO_API bool isConstantColor (const ImageBuf &src, float\nthreshold=0.0f, span color = {}, ROI roi={}, int nthreads=0); /// Does the\nrequested channel have a given value (within a tolerance of +/- /// `threshold`)\nfor every channel within the ROI? (For this function, the /// ROI's\nchbegin/chend are ignored.) Return `true` if so, otherwise return /// `false`.\nIf `roi` is not defined (the default), it will be understood /// to be all of\nthe defined pixels and channels of source. OIIO_API bool isConstantChannel\n(const ImageBuf &src, int channel, float val, float threshold=0.0f, ROI roi={},\nint nthreads=0); /// Is the image monochrome within the ROI, i.e., for every\npixel within the /// region, do all channels [roi.chbegin, roi.chend) have the\nsame value /// (within a tolerance of +/- threshold)? If roi is not defined (the\n/// default), it will be understood to be all of the defined pixels and ///\nchannels of source. OIIO_API bool isMonochrome (const ImageBuf &src, float\nthreshold=0.0f, ROI roi={}, int nthreads=0); /// Count how many pixels in the\nROI match a list of colors. The colors to /// match are in: /// /// colors[0 ...\nnchans-1] /// colors[nchans ... 2*nchans-1] /// ... ///\ncolors[(ncolors-1)*nchans ... (ncolors*nchans)-1] /// /// and so on, a total of\n`ncolors` consecutively stored colors of `nchans` /// channels each (`nchans` is\nthe number of channels in the image, itself, /// it is not passed as a\nparameter). /// /// `eps[0..nchans-1]` are the error tolerances for a match, for\neach /// channel. Setting `eps[c]` = `numeric_limits::max()` will ///\neffectively make it ignore the channel. The default `eps` is 0.001 for /// all\nchannels (this value is chosen because it requires exact matches for /// 8 bit\nimages, but allows a wee bit of imprecision for float images. /// /// Upon\nsuccess, return `true` and store the number of pixels that matched /// each\ncolor `count[0..ncolors-1]`. If there is an error, returns `false` /// and sets\nan appropriate error message set in `src`. bool OIIO_API color_count (const\nImageBuf &src, imagesize_t *count, int ncolors, cspan color, cspan eps = 0.001f,\nROI roi={}, int nthreads=0); /// Count how many pixels in the image (within the\nROI) are outside the /// value range described by\n`low[roi.chbegin..roi.chend-1]` and /// `high[roi.chbegin..roi.chend-1]` as the\nlow and high acceptable values /// for each color channel. /// /// The number of\npixels containing values that fall below the lower bound /// will be stored in\n`*lowcount`, the number of pixels containing /// values that fall above the\nupper bound will be stored in /// `*highcount`, and the number of pixels for\nwhich all channels fell /// within the bounds will be stored in `*inrangecount`.\nAny of these /// may be NULL, which simply means that the counts need not be\ncollected or /// stored. bool OIIO_API color_range_check (const ImageBuf &src,\nimagesize_t *lowcount, imagesize_t *highcount, imagesize_t *inrangecount, cspan\nlow, cspan high, ROI roi={}, int nthreads=0); /// Find the minimal rectangular\nregion within `roi` (which defaults to the /// entire pixel data window of\n`src`) that consists of nonzero pixel /// values. In other words, gives the\nregion that is a \"shrink-wraps\" of /// `src` to exclude black border pixels.\nNote that if the entire image was /// black, the ROI returned will contain no\npixels. /// /// For \"deep\" images, this function returns the smallest ROI that\ncontains /// all pixels that contain depth samples, and excludes the border\npixels /// that contain no depth samples at all. OIIO_API ROI nonzero_region\n(const ImageBuf &src, ROI roi={}, int nthreads=0); /// Compute the SHA-1 byte\nhash for all the pixels in the specified region of /// the image. If `blocksize`\n> 0, the function will compute separate SHA-1 /// hashes of each `blocksize`\nbatch of scanlines, then return a hash of the /// individual hashes. This is\njust as strong a hash, but will NOT match a /// single hash of the entire image\n(`blocksize==0`). But by breaking up /// the hash into independent blocks, we\ncan parallelize across multiple /// threads, given by `nthreads` (if `nthreads`\nis 0, it will use the global /// OIIO thread count). The `extrainfo` provides\nadditional text that will /// be incorporated into the hash. std::string\nOIIO_API computePixelHashSHA1 (const ImageBuf &src, string_view extrainfo = \"\",\nROI roi={}, int blocksize = 0, int nthreads=0); /// Compute a histogram of\n`src`, for the given channel and ROI. Return a /// vector of length `bins` that\ncontains the counts of how many pixel /// values were in each of `bins` equally\nspaced bins covering the range of /// values `[min,max]`. Values < `min` count\nfor bin 0, values > `max` count /// for bin `nbins-1`. If `ignore_empty` is\n`true`, no counts will be /// incremented for any pixels whose value is 0 in all\nchannels. /// /// If there was an error, the returned vector will be empty, and\nan error /// message will be retrievable from src.geterror(). OIIO_API\nstd::vector histogram (const ImageBuf &src, int channel=0, int bins=256, float\nmin=0.0f, float max=1.0f, bool ignore_empty=false, ROI roi={}, int nthreads=0);\n/// Make a 1-channel `float` image of the named kernel. The size of the ///\nimage will be big enough to contain the kernel given its size (`width` x ///\n`height`) and rounded up to odd resolution so that the center of the /// kernel\ncan be at the center of the middle pixel. If width and height /// are 0, the\nnatural size of the named filter will be chosen. The kernel /// image will be\noffset so that its center is at the (0,0) coordinate. If /// `normalize` is\ntrue, the values will be normalized so that they sum to /// 1.0. If `depth` > 1,\na volumetric kernel will be created. Use with /// caution! /// /// Kernel names\ncan be: \"gaussian\", \"sharp-gaussian\", \"box\", /// \"triangle\", \"blackman-harris\",\n\"mitchell\", \"b-spline\", \"catmull-rom\", /// \"lanczos3\", \"disk\", \"binomial\",\n\"laplacian\". /// /// Note that \"catmull-rom\" and \"lanczos3\" are fixed-size\nkernels that /// don't scale with the width, and are therefore probably less\nuseful /// in most cases. /// /// The ImageBuf that is returned indicates if\nthere was an error, in which /// case return.has_error() will be true and\nreturn.geterror() can be used /// to retrieve an error message. ImageBuf\nOIIO_API make_kernel (string_view name, float width, float height, float depth =\n1.0f, bool normalize = true); /// Return the convolution of `src` and a\n`kernel`. If `roi` is not defined, /// it defaults to the full size `src`. If\n`normalized` is true, the kernel will /// be normalized for the convolution,\notherwise the original values will /// be used. ImageBuf OIIO_API convolve\n(const ImageBuf &src, const ImageBuf &kernel, bool normalize = true, ROI roi={},\nint nthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). /// If `roi` is not defined, it defaults to the full size of\n`dst` (or /// `src`, if `dst` was uninitialized). If `dst` is uninitialized, it\nwill /// be allocated to be the size specified by `roi`. bool OIIO_API convolve\n(ImageBuf &dst, const ImageBuf &src, const ImageBuf &kernel, bool normalize =\ntrue, ROI roi={}, int nthreads=0); /// Return the Laplacian of the corresponding\nregion of `src`. The /// Laplacian is the generalized second derivative of the\nimage /// \\f[ /// \\frac{\\partial^2 s}{\\partial x^2} + \\frac{\\partial^2\ns}{\\partial y^2} /// \\f] /// which is approximated by convolving the image with\na discrete 3x3 /// Laplacian kernel, /// /// [ 0 1 0 ] /// [ 1 -4 1 ] /// [ 0 1\n0 ] /// ImageBuf OIIO_API laplacian (const ImageBuf &src, ROI roi={}, int\nnthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API laplacian (ImageBuf &dst, const ImageBuf &src, ROI\nroi={}, int nthreads=0); /// @defgroup fft-ifft (Fast Fourier Transform and\ninverse) /// @{ /// /// Fast Fourier Transform and inverse /// /// Return (or\ncopy into `dst`) the discrete Fourier transform (DFT), or its /// inverse, of\nthe section of `src` denoted by roi, If roi is not defined, /// it will be all\nof `src`'s pixels. /// /// `fft()` takes the discrete Fourier transform (DFT) of\nthe section of /// `src` denoted by `roi`, returning it or storing it in `dst`.\nIf `roi` is /// not defined, it will be all of `src`'s pixels. Only one channel\nof `src` /// may be transformed at a time, so it will be the first channel\ndescribed /// by `roi` (or, again, channel 0 if `roi` is undefined). If not\nalready /// in the correct format, `dst` will be re-allocated to be a 2-channel\n/// `float` buffer of size `roi.width()` x `roi.height`, with channel 0 ///\nbeing the \"real\" part and channel 1 being the the \"imaginary\" part. The ///\nvalues returned are actually the unitary DFT, meaning that it is scaled /// by\n1/sqrt(npixels). /// /// `ifft()` takes the inverse discrete Fourier transform,\ntransforming a /// 2-channel complex (real and imaginary) frequency domain image\nand into a /// single-channel spatial domain image. `src` must be a 2-channel\nfloat /// image, and is assumed to be a complex frequency-domain signal with the\n/// \"real\" component in channel 0 and the \"imaginary\" component in channel 1.\n/// `dst` will end up being a float image of one channel (the real component ///\nis kept, the imaginary component of the spatial-domain will be /// discarded).\nJust as with `fft()`, the `ifft()` function is dealing with /// the unitary DFT,\nso it is scaled by 1/sqrt(npixels). ImageBuf OIIO_API fft (const ImageBuf &src,\nROI roi={}, int nthreads=0); ImageBuf OIIO_API ifft (const ImageBuf &src, ROI\nroi={}, int nthreads=0); bool OIIO_API fft (ImageBuf &dst, const ImageBuf &src,\nROI roi={}, int nthreads=0); bool OIIO_API ifft (ImageBuf &dst, const ImageBuf\n&src, ROI roi={}, int nthreads=0); /// @} /// @defgroup complex-polar\n(Converting complex to polar and back) /// @{ /// /// Converting complex to\npolar and back /// /// The `polar_to_complex()` function transforms a 2-channel\nimage whose /// channels are interpreted as complex values (real and imaginary\n/// components) into the equivalent values expressed in polar form of ///\namplitude and phase (with phase between 0 and \\f$ 2\\pi \\f$. /// /// The\n`complex_to_polar()` function performs the reverse transformation, ///\nconverting from polar values (amplitude and phase) to complex (real and ///\nimaginary). /// /// In either case, the section of `src` denoted by `roi` is\ntransformed, /// storing the result in `dst`. If `roi` is not defined, it will\nbe all of /// `src`'s pixels. Only the first two channels of `src` will be ///\ntransformed. /// /// The transformation between the two representations are: ///\n/// real = amplitude * cos(phase); /// imag = amplitude * sin(phase); /// ///\namplitude = hypot (real, imag); /// phase = atan2 (imag, real); ImageBuf\nOIIO_API complex_to_polar (const ImageBuf &src, ROI roi={}, int nthreads=0);\nbool OIIO_API complex_to_polar (ImageBuf &dst, const ImageBuf &src, ROI roi={},\nint nthreads=0); ImageBuf OIIO_API polar_to_complex (const ImageBuf &src, ROI\nroi={}, int nthreads=0); bool OIIO_API polar_to_complex (ImageBuf &dst, const\nImageBuf &src, ROI roi={}, int nthreads=0); /// @} enum NonFiniteFixMode {\nNONFINITE_NONE = 0, ///< Do not alter the pixels (but do count the ///< number\nof nonfinite pixels in *pixelsFixed, ///< if non-null). NONFINITE_BLACK = 1,\n///< Replace non-finite values with 0.0. NONFINITE_BOX3 = 2, ///< Replace\nnon-finite values with the average ///< value of any finite pixels in a 3x3\nwindow. NONFINITE_ERROR = 100, ///< Return false (error), but don't change any\n///< values, if any nonfinite values are found. }; /// `fixNonFinite()` returns\nan image containing the values of `src` (within /// the ROI), while repairing\nany non-finite (NaN/Inf) pixels. If /// `pixelsFixed` is not nullptr, store in\nit the number of pixels that /// contained non-finite value. It is permissible\nto operate in-place (with /// `src` and `dst` referring to the same image). ///\n/// How the non-finite values are repaired is specified by one of the `mode` ///\nparameter, which is an enum of `NonFiniteFixMode`. /// /// This function works\non all pixel data types, though it's just a copy for /// images with pixel data\ntypes that cannot represent NaN or Inf values. ImageBuf OIIO_API fixNonFinite\n(const ImageBuf &src, NonFiniteFixMode mode=NONFINITE_BOX3, int *pixelsFixed =\nnullptr, ROI roi={}, int nthreads=0); /// Write to an existing image `dst`\n(allocating if it is uninitialized). bool OIIO_API fixNonFinite (ImageBuf &dst,\nconst ImageBuf &src, NonFiniteFixMode mode=NONFINITE_BOX3, int *pixelsFixed =\nnullptr, ROI roi={}, int nthreads=0); /// Copy the specified ROI of `src` and\nfill any holes (pixels where alpha < /// 1) with plausible values using a\npush-pull technique. The `src` image /// must have an alpha channel. The `dst`\nimage will end up with a copy of /// `src`, but will have an alpha of 1.0\neverywhere within `roi`, and any /// place where the alpha of `src` was < 1,\n`dst` will have a pixel color /// that is a plausible \"filling\" of the original\nalpha hole. ImageBuf OIIO_API fillholes_pushpull (const ImageBuf &src, ROI\nroi={}, int nthreads=0); /// Write to an existing image `dst` (allocating if it\nis uninitialized). bool OIIO_API fillholes_pushpull (ImageBuf &dst, const\nImageBuf &src, ROI roi={}, int nthreads=0); /// Return a median-filtered version\nof the corresponding region of `src`. /// The median filter replaces each pixel\nwith the median value underneath /// the `width` x `height` window surrounding\nit. If `height` <= 0, it will /// be set to `width`, making a square window. ///\n/// Median filters are good for removing high-frequency detail smaller than ///\nthe window size (including noise), without blurring edges that are /// larger\nthan the window size. ImageBuf OIIO_API median_filter (const ImageBuf &src, int\nwidth = 3, int height = -1, ROI roi={}, int nthreads=0); /// Write to an\nexisting image `dst` (allocating if it is uninitialized). bool OIIO_API\nmedian_filter (ImageBuf &dst, const ImageBuf &src, int width = 3, int height =\n-1, ROI roi={}, int nthreads=0); /// Return a sharpened version of the\ncorresponding region of `src` using /// the \"unsharp mask\" technique. Unsharp\nmasking basically works by first /// blurring the image (low pass filter),\nsubtracting this from the original /// image, then adding the residual back to\nthe original to emphasize the /// edges. Roughly speaking, /// /// dst = src +\ncontrast * thresh(src - blur(src)) /// /// The specific blur can be selected by\nkernel name and width (for example, /// \"gaussian\" is typical). As a special\ncase, \"median\" is also accepted as /// the kernel name, in which case a median\nfilter is performed rather than /// a blurring convolution (Gaussian and other\nblurs sometimes over-sharpen /// edges, whereas using the median filter will\nsharpen compact /// high-frequency details while not over-sharpening long\nedges). /// /// The `contrast` is a multiplier on the overall sharpening effect.\nThe /// thresholding step causes all differences less than `threshold` to be ///\nsquashed to zero, which can be useful for suppressing sharpening of ///\nlow-contrast details (like noise) but allow sharpening of /// higher-contrast\nedges. ImageBuf OIIO_API unsharp_mask (const ImageBuf &src, string_view\nkernel=\"gaussian\", float width = 3.0f, float contrast = 1.0f, float threshold =\n0.0f, ROI roi={}, int nthreads=0); /// Write to an existing image `dst`\n(allocating if it is uninitialized). bool OIIO_API unsharp_mask (ImageBuf &dst,\nconst ImageBuf &src, string_view kernel=\"gaussian\", float width = 3.0f, float\ncontrast = 1.0f, float threshold = 0.0f, ROI roi={}, int nthreads=0); /// Return\na dilated version of the corresponding region of `src`. Dilation /// is defined\nas the maximum value of all pixels under nonzero values of /// the structuring\nelement (which is taken to be a width x height square). /// If height is not\nset, it will default to be the same as width. Dilation /// makes bright features\nwider and more prominent, dark features thinner, /// and removes small isolated\ndark spots. ImageBuf OIIO_API dilate (const ImageBuf &src, int width=3, int\nheight=-1, ROI roi={}, int nthreads=0); /// Write to an existing image `dst`\n(allocating if it is uninitialized). bool OIIO_API dilate (ImageBuf &dst, const\nImageBuf &src, int width=3, int height=-1, ROI roi={}, int nthreads=0); ///\nReturn an eroded version of the corresponding region of `src`. Erosion /// is\ndefined as the minimum value of all pixels under nonzero values of /// the\nstructuring element (which is taken to be a width x height square). /// If\nheight is not set, it will default to be the same as width. Erosion /// makes\ndark features wider, bright features thinner, and removes small /// isolated\nbright spots. ImageBuf OIIO_API erode (const ImageBuf &src, int width=3, int\nheight=-1, ROI roi={}, int nthreads=0); /// Write to an existing image `dst`\n(allocating if it is uninitialized). bool OIIO_API erode (ImageBuf &dst, const\nImageBuf &src, int width=3, int height=-1, ROI roi={}, int nthreads=0); ///\n@defgroup colorconvert (Color space conversions) /// @{ /// /// Convert between\ncolor spaces /// /// Return (or copy into `dst`) the pixels of `src` within the\nROI, applying /// a color space transformation. In-place operations (`dst` ==\n`src`) are /// supported. /// /// The first three channels are presumed to be\nthe color to be /// transformed, and the fourth channel (if it exists) is\npresumed to be /// alpha. Any additional channels will be simply copied\nunaltered. /// /// The transformation may be between any two spaces supported by\nthe active /// OCIO configuration, or may be a \"look\" transformation created by\n/// `ColorConfig::createLookTransform`. /// /// @param fromspace/tospace /// For\nthe varieties of `colorconvert()` that use named color /// spaces, these specify\nthe color spaces by name. /// @param context_key/context_value /// For the\nvarieties of `colorconvert()` that use named color /// spaces, these optionally\nspecify a \"key\" name/value pair to /// establish a context (for example, a\nshot-specific transform). /// @param processor /// For the varieties of\n`colorconvert()` that have a /// `processor` parameter, it is a raw\n`ColorProcessor*` object /// that implements the color transformation. This is a\nspecial /// object created by a `ColorConfig` (see `OpenImageIO/color.h` /// for\ndetails). /// @param unpremult /// If true, unpremultiply the image (divide the\nRGB channels by /// alpha if it exists and is nonzero) before color conversion,\n/// then repremult after the after the color conversion. Passing ///\nunpremult=false skips this step, which may be desirable if /// you know that the\nimage is \"unassociated alpha\" (a.k.a., /// \"not pre-multiplied colors\"). ///\n@param colorconfig /// An optional `ColorConfig*` specifying an OpenColorIO ///\nconfiguration. If not supplied, the default OpenColorIO /// color configuration\nfound by examining the `$OCIO` /// environment variable will be used instead.\n/// /// Transform between named color spaces, returning an ImageBuf result.\nImageBuf OIIO_API colorconvert (const ImageBuf &src, string_view fromspace,\nstring_view tospace, bool unpremult=true, string_view context_key=\"\",\nstring_view context_value=\"\", const ColorConfig* colorconfig = nullptr, ROI\nroi={}, int nthreads=0); /// Transform using a ColorProcessor, returning an\nImageBuf result. ImageBuf OIIO_API colorconvert (const ImageBuf &src, const\nColorProcessor *processor, bool unpremult, ROI roi={}, int nthreads=0); ///\nTransform between named color spaces, storing reults into an existing ImageBuf.\nbool OIIO_API colorconvert (ImageBuf &dst, const ImageBuf &src, string_view\nfromspace, string_view tospace, bool unpremult=true, string_view context_key=\"\",\nstring_view context_value=\"\", const ColorConfig* colorconfig = nullptr, ROI\nroi={}, int nthreads=0); /// Transform using a ColorProcessor, storing reults\ninto an existing ImageBuf. bool OIIO_API colorconvert (ImageBuf &dst, const\nImageBuf &src, const ColorProcessor *processor, bool unpremult, ROI roi={}, int\nnthreads=0); /// Apply a color transform in-place to just one color: ///\n`color[0..nchannels-1]`. `nchannels` should either be 3 or 4 (if 4, the /// last\nchannel is alpha). bool OIIO_API colorconvert (span color, const ColorProcessor\n*processor, bool unpremult); /// @} /// Return a copy of the pixels of `src`\nwithin the ROI, applying a color /// transform specified by a 4x4 matrix.\nIn-place operations /// (`dst` == `src`) are supported. /// /// The first three\nchannels are presumed to be the color to be /// transformed, and the fourth\nchannel (if it exists) is presumed to be /// alpha. Any additional channels will\nbe simply copied unaltered. /// /// @param M /// A 4x4 matrix. Following Imath\nconventions, the color is a /// row vector and the matrix has the \"translation\"\npart in /// elements [12..14] (matching the memory layout of OpenGL or ///\nRenderMan), so the math is `color * Matrix` (NOT `M*c`). /// @param unpremult\n/// If true, unpremultiply the image (divide the RGB channels by /// alpha if it\nexists and is nonzero) before color conversion, /// then repremult after the\nafter the color conversion. Passing /// unpremult=false skips this step, which\nmay be desirable if /// you know that the image is \"unassociated alpha\" (a.k.a.,\n/// \"not pre-multiplied colors\"). /// /// @version 2.1+ /// ImageBuf OIIO_API\ncolormatrixtransform (const ImageBuf &src, M44fParam M, bool unpremult=true, ROI\nroi={}, int nthreads=0); /// Write to an existing image `dst` (allocating if it\nis uninitialized). bool OIIO_API colormatrixtransform (ImageBuf &dst, const\nImageBuf &src, M44fParam M, bool unpremult=true, ROI roi={}, int nthreads=0);\n/// Return a copy of the pixels of `src` within the ROI, applying an ///\nOpenColorIO \"look\" transform to the pixel values. In-place operations /// (`dst`\n== `src`) are supported. /// /// The first three channels are presumed to be the\ncolor to be /// transformed, and the fourth channel (if it exists) is presumed\nto be /// alpha. Any additional channels will be simply copied unaltered. ///\n/// @param looks /// The looks to apply (comma-separated). /// @param\nfromspace/tospace /// For the varieties of `colorconvert()` that use named color\n/// spaces, these specify the color spaces by name. If either /// is the empty\nstring, it will use `\"scene_linear\"`. /// @param unpremult /// If true,\nunpremultiply the image (divide the RGB channels by /// alpha if it exists and\nis nonzero) before color conversion, /// then repremult after the after the\ncolor conversion. Passing /// unpremult=false skips this step, which may be\ndesirable if /// you know that the image is \"unassociated alpha\" (a.k.a., ///\n\"not pre-multiplied colors\"). /// @param inverse /// If `true`, it will reverse\nthe color transformation and look /// application. /// @param\ncontext_key/context_value /// Optional key/value to establish a context (for\nexample, a /// shot-specific transform). /// @param colorconfig /// An optional\n`ColorConfig*` specifying an OpenColorIO /// configuration. If not supplied, the\ndefault OpenColorIO /// color configuration found by examining the `$OCIO` ///\nenvironment variable will be used instead. ImageBuf OIIO_API ociolook (const\nImageBuf &src, string_view looks, string_view fromspace, string_view tospace,\nbool unpremult=true, bool inverse=false, string_view context_key=\"\", string_view\ncontext_value=\"\", const ColorConfig* colorconfig = nullptr, ROI roi={}, int\nnthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API ociolook (ImageBuf &dst, const ImageBuf &src,\nstring_view looks, string_view fromspace, string_view tospace, bool\nunpremult=true, bool inverse=false, string_view context_key=\"\", string_view\ncontext_value=\"\", const ColorConfig* colorconfig = nullptr, ROI roi={}, int\nnthreads=0); /// Return the pixels of `src` within the ROI, applying an\nOpenColorIO /// \"display\" transform to the pixel values. In-place operations ///\n(`dst` == `src`) are supported. /// /// The first three channels are presumed to\nbe the color to be /// transformed, and the fourth channel (if it exists) is\npresumed to be /// alpha. Any additional channels will be simply copied\nunaltered. /// /// @param display /// The OCIO \"display\" to apply. If this is\n`\"default\"` or the /// empty string `\"\"`, the default display will be used. ///\n@param view /// The OCIO \"view\" to use. If this is `\"default\"` or the empty ///\nstring `\"\"`, the default view for this display will be used. /// @param\nfromspace /// If `fromspace` is not supplied, it will assume that the /// source\ncolor space is whatever is indicated by the source /// image's metadata or\nfilename, and if that cannot be deduced, /// it will be assumed to be\n`\"scene_linear\"`. /// @param looks /// The looks to apply (comma-separated).\nThis may be empty, /// in which case no \"look\" is used. Note: this parameter\nvalue /// is not used when building against OpenColorIO 2.x. /// @param\nunpremult /// If true, unpremultiply the image (divide the RGB channels by ///\nalpha if it exists and is nonzero) before color conversion, /// then repremult\nafter the after the color conversion. Passing /// unpremult=false skips this\nstep, which may be desirable if /// you know that the image is \"unassociated\nalpha\" (a.k.a., /// \"not pre-multiplied colors\"). /// @param inverse /// If\n`true`, it will reverse the color transformation and /// display application.\n/// @param context_key/context_value /// Optional key/value to establish a\ncontext (for example, a /// shot-specific transform). /// @param colorconfig ///\nAn optional `ColorConfig*` specifying an OpenColorIO /// configuration. If not\nsupplied, the default OpenColorIO /// color configuration found by examining the\n`$OCIO` /// environment variable will be used instead. ImageBuf OIIO_API\nociodisplay (const ImageBuf &src, string_view display, string_view view,\nstring_view fromspace=\"\", string_view looks=\"\", bool unpremult=true, bool\ninverse=false, string_view context_key=\"\", string_view context_value=\"\", const\nColorConfig* colorconfig = nullptr, ROI roi={}, int nthreads=0); /// Write to an\nexisting image `dst` (allocating if it is uninitialized). bool OIIO_API\nociodisplay (ImageBuf &dst, const ImageBuf &src, string_view display,\nstring_view view, string_view fromspace=\"\", string_view looks=\"\", bool\nunpremult=true, bool inverse=false, string_view context_key=\"\", string_view\ncontext_value=\"\", const ColorConfig* colorconfig = nullptr, ROI roi={}, int\nnthreads=0); /// Return the pixels of `src` within the ROI, applying an\nOpenColorIO /// \"file\" transform. In-place operations (`dst` == `src`) are\nsupported. /// /// The first three channels are presumed to be the color to be\n/// transformed, and the fourth channel (if it exists) is presumed to be ///\nalpha. Any additional channels will be simply copied unaltered. /// /// @param\nname /// The name of the file containing the transform information. /// @param\nunpremult /// If true, unpremultiply the image (divide the RGB channels by ///\nalpha if it exists and is nonzero) before color conversion, /// then repremult\nafter the after the color conversion. Passing /// unpremult=false skips this\nstep, which may be desirable if /// you know that the image is \"unassociated\nalpha\" (a.k.a., /// \"not pre-multiplied colors\"). /// @param inverse /// If\n`true`, it will reverse the color transformation. /// @param colorconfig /// An\noptional `ColorConfig*` specifying an OpenColorIO /// configuration. If not\nsupplied, the default OpenColorIO /// color configuration found by examining the\n`$OCIO` /// environment variable will be used instead. ImageBuf OIIO_API\nociofiletransform (const ImageBuf &src, string_view name, bool unpremult=true,\nbool inverse=false, const ColorConfig* colorconfig = nullptr, ROI roi={}, int\nnthreads=0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API ociofiletransform (ImageBuf &dst, const ImageBuf\n&src, string_view name, bool unpremult=true, bool inverse=false, const\nColorConfig* colorconfig = nullptr, ROI roi={}, int nthreads=0); /// Return the\npixels of `src` within the ROI, applying an OpenColorIO /// \"named\" transform to\nthe pixel values. In-place operations /// (`dst` == `src`) are supported. ///\n/// The first three channels are presumed to be the color to be /// transformed,\nand the fourth channel (if it exists) is presumed to be /// alpha. Any\nadditional channels will be simply copied unaltered. /// /// @param name /// The\nname of the OCIO NamedTransform to apply. /// @param unpremult /// If true,\nunpremultiply the image (divide the RGB channels by /// alpha if it exists and\nis nonzero) before color conversion, /// then repremult after the after the\ncolor conversion. Passing /// unpremult=false skips this step, which may be\ndesirable if /// you know that the image is \"unassociated alpha\" (a.k.a., ///\n\"not pre-multiplied colors\"). /// @param inverse /// If `true`, it will apply\nthe NamedTransform in the inverse /// direction. /// @param\ncontext_key/context_value /// Optional key/value to establish a context (for\nexample, a /// shot-specific transform). /// @param colorconfig /// An optional\n`ColorConfig*` specifying an OpenColorIO /// configuration. If not supplied, the\ndefault OpenColorIO /// color configuration found by examining the `$OCIO` ///\nenvironment variable will be used instead. ImageBuf OIIO_API ocionamedtransform\n(const ImageBuf &src, string_view name, bool unpremult=true, bool inverse=false,\nstring_view context_key=\"\", string_view context_value=\"\", const ColorConfig*\ncolorconfig = nullptr, ROI roi={}, int nthreads=0); /// Write to an existing\nimage `dst` (allocating if it is uninitialized). bool OIIO_API\nocionamedtransform (ImageBuf &dst, const ImageBuf &src, string_view name, bool\nunpremult=true, bool inverse=false, string_view context_key=\"\", string_view\ncontext_value=\"\", const ColorConfig* colorconfig = nullptr, ROI roi={}, int\nnthreads=0); /// @defgroup premult (Premultiply or un-premultiply color by\nalpha) /// @{ /// /// Premultiply or un-premultiply color by alpha /// /// The\n`unpremult` operation returns (or copies into `dst`) the pixels of /// `src`\nwithin the ROI, and in the process divides all color channels /// (those not\nalpha or z) by the alpha value, to \"un-premultiply\" them. /// This presumes that\nthe image starts of as \"associated alpha\" a.k.a. /// \"premultiplied,\" and you\nare converting to \"unassociated alpha.\" For /// pixels with alpha == 0, the\ncolor values are not modified. /// /// The `premult` operation returns (or\ncopies into `dst`) the pixels of /// `src` within the ROI, and in the process\nmultiplies all color channels /// (those not alpha or z) by the alpha value, to\n\"premultiply\" them. This /// presumes that the image starts of as \"unassociated\nalpha\" a.k.a. /// \"non-premultiplied\" and converts it to \"associated alpha /\npremultiplied.\" /// /// The `repremult` operation is like `premult`, but\npreserves the color /// values of pixels whose alpha is 0. This is intended for\ncases where you /// unpremult, do an operation (such as color transforms), then\nwant to /// return to associated/premultiplied alpha -- in that case, you want\nto /// make sure that \"glow\" pixels (those with alpha=0 but RGB > 0) are ///\npreserved for the round trip, and not crushed to black. This use case is ///\ndistinct from a simple `premult` that is a one-time conversion from ///\nunassociated to associated alpha. /// /// All three operations are simply a copy\nif there is no identified alpha /// channel (and a no-op if `dst` and `src` are\nthe same image). ImageBuf OIIO_API unpremult (const ImageBuf &src, ROI roi={},\nint nthreads=0); bool OIIO_API unpremult (ImageBuf &dst, const ImageBuf &src,\nROI roi={}, int nthreads=0); ImageBuf OIIO_API premult (const ImageBuf &src, ROI\nroi={}, int nthreads=0); bool OIIO_API premult (ImageBuf &dst, const ImageBuf\n&src, ROI roi={}, int nthreads=0); ImageBuf OIIO_API repremult (const ImageBuf\n&src, ROI roi={}, int nthreads=0); bool OIIO_API repremult (ImageBuf &dst, const\nImageBuf &src, ROI roi={}, int nthreads=0); /// @} /// Performs demosaicing of a\nraw digital camera image. Expects the `src` to be a single channel image. ///\nReturns a three channel RGB image with the color channels reconstructed using\nthe selected algorithm. /// /// @param options /// Optional ParamValue's that\nmay control the reconstruction. /// /// The `options` list contains optional\nParamValue's that may control the reconstruction. /// The following options are\nrecognized: /// /// - \"pattern\" : string (default: \"auto\") /// /// The type of\nimage sensor color filter array. Currently suported patterns: /// - `bayer` -\nBayer-pattern image. /// - `xtrans` - X-Trans-pattern image. /// - `auto` - the\npattern is deducted from the \"raw:FilterPattern\" attribute of the source image\nbuffer. /// /// - \"algorithm\" : string (default: \"auto\") /// /// The demosaicing\nalgorithm, pattern-specific. /// The following algorithms are supported for\nBayer-pattern images: /// - `linear` - simple bilinear demosaicing. Fast, but\ncan produce artefacts along sharp edges. /// - `MHC` - Malvar-He-Cutler linear\ndemosaicing algorithm. Slower than `linear`, but produces /// significantly\nbetter results. /// - `auto` - same as \"MHC\" /// /// The following algorithms\nare supported for X-Trans-pattern images: /// - `linear` - simple linear\ndemosaicing. Fast, but can produce artefacts along sharp edges. /// - `auto` -\nsame as \"linear\" /// /// - \"layout\" : string (default: \"auto\") /// /// The order\nthe color filter array elements are arranged in, pattern-specific. The Bayer\npattern sensors /// usually have 4 values in the layout string, describing the\n2x2 pixels region. The X-Trans pattern /// sensors have 36 values in the layout\nstring, describing the 6x6 pixels region (with optional /// whitespaces\nseparating the rows). When set to \"auto\", OIIO will try to fetch the layout from\nthe /// \"raw:FilterPattern\" attribute of the source image buffer, falling back\nto \"RGGB\" for Bayer, /// \"GRBGBR BGGRGG RGGBGG GBRGRB RGGBGG BGGRGG\" for X-Trans\nif absent. /// /// - \"white_balance_mode\" : string (default: \"auto\") /// ///\nWhite-balancing mode. The following modes are supported: /// - `auto` - OIIO\nwill try to fetch the white balancing weights from the \"raw:WhiteBalance\" ///\nattribute of the source image buffer, falling back to {1.0, 1.0, 1.0, 1.0} if\nabsent. /// - `manual` - The white balancing weights will be taken from the\nattribute `white_balance` (see below) /// if present, falling back to {1.0, 1.0,\n1.0, 1.0} if absent. /// - `none` - no white balancing will be performed. ///\n/// - \"white_balance\" : float[3] or float[4] /// /// Optional white-balancing\nweights. Can contain either three (R,G,B), or four (R,G1,B,G2) values. /// The\norder of the white balance multipliers does not depend on the matrix layout.\nImageBuf OIIO_API demosaic (const ImageBuf& src, KWArgs options = {}, ROI roi =\n{}, int nthreads = 0); /// Write to an existing image `dst` (allocating if it is\nuninitialized). bool OIIO_API demosaic (ImageBuf& dst, const ImageBuf& src,\nKWArgs options = {}, ROI roi = {}, int nthreads = 0); enum MakeTextureMode {\nMakeTxTexture, MakeTxShadow, MakeTxEnvLatl, MakeTxEnvLatlFromLightProbe,\nMakeTxBumpWithSlopes, _MakeTxLast }; /// @defgroup make_texture (make_texture --\nTurn an image into a texture) /// @{ /// /// The `make_texture()` function turns\nan image into a tiled, MIP-mapped, /// texture file and write it to disk\n(outputfilename). /// /// The return value is `true` for success, `false` if an\nerror occurred. If /// there was an error, any error message will be retrievable\nvia the global /// `OIIO::geterror()` call (since there is no destination\n`ImageBuf` in /// which to store it). /// /// Named fields in config: /// /// -\nformat : Data format of the texture file (default: UNKNOWN = same /// format as\nthe input) /// - tile_width/tile_height/tile_depth : /// Preferred tile size\n(default: 64x64x1) /// /// Metadata in `config.extra_attribs` /// /// -\n`compression` (string) : Default: \"zip\" /// - `fovcot` (float) : Default: aspect\nratio of the image /// resolution. /// - `planarconfig` (string) : Default:\n\"separate\" /// - `worldtocamera` (matrix) : World-to-camera matrix of the view.\n/// - `worldtoscreen` (matrix) : World-to-screen space matrix of the view. /// -\n`worldtoNDC` (matrix) : World-to-NDC space matrix of the view. /// - `wrapmodes`\n(string) : Default: \"black,black\" /// - `handed` (string) : \"left\" or \"right\"\nreveals the handedness of /// the coordinates for normal maps. (\"\") /// -\n`maketx:verbose` (int) : How much detail should go to outstream (0). /// -\n`maketx:runstats` (int) : If nonzero, print run stats to outstream (0). /// -\n`maketx:resize` (int) : If nonzero, resize to power of 2. (0) /// -\n`maketx:keepaspect` (int): If nonzero, save aspect ratio to metadata. (0) /// -\n`maketx:nomipmap` (int) : If nonzero, only output the top MIP level (0). /// -\n`maketx:updatemode` (int) : If nonzero, write new output only if the /// output\nfile doesn't already exist, or is /// older than the input file, or was created\n/// with different command-line arguments. (0) /// -\n`maketx:constant_color_detect` (int) : /// If nonzero, detect images that are\nentirely /// one color, and change them to be low /// resolution (default: 0).\n/// - `maketx:monochrome_detect` (int) : /// If nonzero, change RGB images which\nhave /// R==G==B everywhere to single-channel /// grayscale (default: 0). /// -\n`maketx:opaque_detect` (int) : /// If nonzero, drop the alpha channel if alpha\n/// is 1.0 in all pixels (default: 0). /// - `maketx:compute_average` (int) :\n/// If nonzero, compute and store the average /// color of the texture (default:\n1). /// - `maketx:unpremult` (int) : If nonzero, unpremultiply color by alpha\n/// before color conversion, then multiply by /// alpha after color conversion\n(default: 0). /// - `maketx:incolorspace`, `maketx:outcolorspace` (string) : ///\nThese two together will apply a color conversion /// (with OpenColorIO, if\ncompiled). Default: \"\" /// - `maketx:colorconfig` (string) : /// Specifies a\ncustom OpenColorIO color config /// file. Default: \"\" /// - `maketx:checknan`\n(int) : If nonzero, will consider it an error if the /// input image has any NaN\npixels. (0) /// - `maketx:fixnan` (string) : If set to \"black\" or \"box3\", will\nattempt /// to repair any NaN pixels found in the /// input image (default:\n\"none\"). /// - `maketx:set_full_to_pixels` (int) : /// If nonzero, doctors the\nfull/display window /// of the texture to be identical to the /// pixel/data\nwindow and reset the origin /// to 0,0 (default: 0). /// - `maketx:filtername`\n(string) : /// If set, will specify the name of a high-quality /// filter to use\nwhen resampling for MIPmap /// levels. Default: \"\", use bilinear resampling. ///\n- `maketx:highlightcomp` (int) : /// If nonzero, performs highlight compensation\n-- /// range compression and expansion around /// the resize, plus clamping\nnegative pixel /// values to zero. This reduces ringing when /// using filters\nwith negative lobes on HDR /// images. /// - `maketx:sharpen` (float) : If\nnonzero, sharpens details when creating /// MIPmap levels. The amount is the\ncontrast /// metric. The default is 0, meaning no /// sharpening. /// -\n`maketx:nchannels` (int) : If nonzero, will specify how many channels /// the\noutput texture should have, padding with /// 0 values or dropping channels, if\nit doesn't /// the number of channels in the input. /// (default: 0, meaning\nkeep all input channels) /// - `maketx:channelnames` (string) : /// If set,\noverrides the channel names of the /// output image (comma-separated). /// -\n`maketx:fileformatname` (string) : /// If set, will specify the output file\nformat. /// (default: \"\", meaning infer the format from /// the output filename)\n/// - `maketx:oiio_options` (int) : /// (Deprecated; all are handled by default)\n/// - `maketx:prman_options` (int) : /// If nonzero, override a whole bunch of\nsettings /// as needed to make textures that are /// compatible with PRMan. This\nalso enables /// prman_metadata. (0) /// - `maketx:prman_metadata` (int) : ///\nIf set, output some metadata that PRMan will /// need for its textures. (0) ///\n- `maketx:mipimages` (string) : /// Semicolon-separated list of alternate images\n/// to be used for individual MIPmap levels, /// rather than simply downsizing.\n(default: \"\") /// - `maketx:mipmap_metadata` (int) : /// If nonzero, will\npropagate metadata to every MIP /// level. The default (0) only writes metadata\nto /// the highest-resolution level. (0) /// - `maketx:full_command_line`\n(string) : /// The command or program used to generate this /// call, will be\nembedded in the metadata. /// (default: \"\") /// - `maketx:ignore_unassoc` (int)\n: /// If nonzero, will disbelieve any evidence that /// the input image is\nunassociated alpha. (0) /// - `maketx:read_local_MB` (int) : /// If nonzero,\nwill read the full input file /// locally if it is smaller than this ///\nthreshold. Zero causes the system to make a /// good guess at a reasonable\nthreshold (e.g. 1 /// GB). (0) /// - `maketx:forcefloat` (int) : /// Forces a\nconversion through float data for /// the sake of ImageBuf math. (1) /// -\n`maketx:hash` (int) : /// Compute the sha1 hash of the file in parallel. (1) ///\n- `maketx:allow_pixel_shift` (int) : /// Allow up to a half pixel shift per\nmipmap level. /// The fastest path may result in a slight shift /// in the\nimage, accumulated for each mip level /// with an odd resolution. (0) /// -\n`maketx:bumpformat` (string) : /// For the MakeTxBumpWithSlopes mode, chooses\n/// whether to assume the map is a height map /// (\"height\"), a normal map\n(\"normal\"), or /// automatically determine it from the number /// of channels\n(\"auto\", the default). /// - `maketx:uvslopes_scale` (float) : /// If nonzero,\nwhen used in MakeTxBumpWithSlopes /// mode, this computes derivatives for the\n/// bumpslopes data in UV space rather than in /// texel space, and divides them\nby this scale /// factor. The default is 0, disabling the /// feature. If you\nuse this feature, a suggested /// value is 256. /// - `maketx:slopefilter`\n(string) : /// When used in MakeTxBumpWithSlopes mode, this /// sets the filter\nfor computing the slopes when /// `--bumpformat` is set to \"height\". The default\n/// value is \"sobel\". The option \"centraldiff\" /// matches the behavior of\n`txmake` and is less /// prone to ring-shaped artifacting. (sobel) /// -\n`maketx:bumpinverts` (int) : /// When used in MakeTxBumpWithSlopes mode, a ///\nnon-zero value inverts the computed slopes on the /// s/u/x direction. (0) /// -\n`maketx:bumpinvertt` (int) : /// When used in MakeTxBumpWithSlopes mode, a ///\nnon-zero value inverts the computed slopes on the /// t/v/y direction. (0) /// -\n`maketx:bumpscale` (float) : /// When used in MakeTxBumpWithSlopes mode, this\n/// scales the strength of the resulting bumpslopes /// map. (1.0) /// -\n`maketx:bumprange` (string) : /// When used in MakeTxBumpWithSlopes mode, this\n/// sets the convention used for normal map data when /// `--bumpformat` is set\nto \"normal\". When set to /// \"centered\", the normals data is assumed to exist\n/// on the range [-1,1]. When set to \"positive\", the /// normals data is assumed\nto exist on the range /// [0,1]. When set to \"auto\", the default value, the ///\nrange is inferred based on whether or not /// negative values are present in the\ninput image. /// (auto) /// - `maketx:cdf` (int) : /// If nonzero, will write a\nGaussian CDF and /// Inverse Gaussian CDF as per-channel metadata /// in the\ntexture, which can be used by shaders /// to implement Histogram-Preserving\nBlending. /// This is only useful when the texture being /// created is written\nto an image format that /// supports arbitrary metadata (e.g. OpenEXR). /// (See\nBurley, \"On Histogram-Preserving Blending /// for Randomized Texture Tiling,\"\nJCGT 8(4), 2019, /// and Heitz/Neyret, \"High-Performance By-Example /// Noise\nusing a Histogram-Preserving Blending /// Operator,\" ACM SIGGRAPH / Eurographics\nSymposium /// on High-Performance Graphics 2018.) (default: 0) /// -\n`maketx:cdfsigma` (float) : /// When `maketx:cdf` is active, determines the ///\nCDF sigma (default: 1.0/6). /// - `maketx:cdfbits` (int) : /// When `maketx:cdf`\nis active, determines the /// number of bits to use for the size of the CDF ///\ntable. (default: 8, meaning 256 bins) /// /// @param mode /// Describes what\ntype of texture file we are creating and may /// be one of: /// -\n`MakeTxTexture` : Ordinary 2D texture. /// - `MakeTxEnvLatl` :\nLatitude-longitude environment map /// - `MakeTxEnvLatlFromLightProbe` :\nLatitude-longitude environment map /// constructed from a \"light probe\" ///\nimage. /// - `MakeTxBumpWithSlopes` : Bump/displacement map with extra slope ///\ndata channels (6 channels total, /// containing both the height and 1st and ///\n2nd moments of slope distributions) for /// bump-to-roughness conversion in\nshaders. /// @param outputfilename /// Name of the file in which to save the\nresulting texture. /// @param config An ImageSpec that contains all the\ninformation and /// special instructions for making the texture. Anything set in\nconfig /// (format, tile size, or named metadata) will take precedence over ///\nwhatever is specified by the input file itself. Additionally, named /// metadata\nthat starts with \"maketx:\" will not be output to the file /// itself, but may\ncontain instructions controlling how the texture is /// created. The full list\nof supported configuration options is listed /// below. /// @param outstream ///\nIf not `nullptr`, it should point to a stream (for example, /// `&std::out`, or\na pointer to a local `std::stringstream` to capture /// output), which is where\nconsole output and errors will be /// deposited. Note that error messages will\nalso be retrievable from /// OIIO::geterror(). /// /// /// Version of\nmake_texture that starts with an ImageBuf. bool OIIO_API make_texture\n(MakeTextureMode mode, const ImageBuf &input, string_view outputfilename, const\nImageSpec &config, std::ostream *outstream = nullptr); /// Version of\nmake_texture that starts with a filename and reads the input /// from that file,\nrather than being given an ImageBuf directly. bool OIIO_API make_texture\n(MakeTextureMode mode, string_view filename, string_view outputfilename, const\nImageSpec &config, std::ostream *outstream = nullptr); /// Version of\nmake_texture that takes multiple filenames (reserved for /// future expansion,\nsuch as assembling several faces into a cube map). bool OIIO_API make_texture\n(MakeTextureMode mode, const std::vector &filenames, string_view outputfilename,\nconst ImageSpec &config, std::ostream *outstream = nullptr); /// @} /// Return\nthe \"deep\" equivalent of the \"flat\" input `src`. Turning a flat /// image into a\ndeep one means: /// /// * If the `src` image has a \"Z\" channel: if the source\npixel's Z channel /// value is not infinite, the corresponding pixel of `dst`\nwill get a /// single depth sample that copies the data from the source pixel;\n/// otherwise, dst will get an empty pixel. In other words, infinitely far ///\npixels will not turn into deep samples. /// /// * If the `src` image lacks a \"Z\"\nchannel: if any of the source pixel's /// channel values are nonzero, the\ncorresponding pixel of `dst` will get /// a single depth sample that copies the\ndata from the source pixel and /// uses the zvalue parameter for the depth;\notherwise, if all source /// channels in that pixel are zero, the destination\npixel will get no /// depth samples. /// /// If `src` is already a deep image,\nit will just copy pixel values from /// `src`. ImageBuf OIIO_API deepen (const\nImageBuf &src, float zvalue = 1.0f, ROI roi={}, int nthreads=0); /// Write to an\nexisting image `dst` (allocating if it is uninitialized). bool OIIO_API deepen\n(ImageBuf &dst, const ImageBuf &src, float zvalue = 1.0f, ROI roi={}, int\nnthreads=0); /// Return the \"flattened\" composite of deep image `src`. That is,\nit /// converts a deep image to a simple flat image by front-to- back ///\ncompositing the samples within each pixel. If `src` is already a ///\nnon-deep/flat image, it will just copy pixel values from `src` to `dst`. /// If\n`dst` is not already an initialized ImageBuf, it will be sized to /// match\n`src` (but made non-deep). ImageBuf OIIO_API flatten (const ImageBuf &src, ROI\nroi={}, int nthreads=0); /// Write to an existing image `dst` (allocating if it\nis uninitialized). bool OIIO_API flatten (ImageBuf &dst, const ImageBuf &src,\nROI roi={}, int nthreads=0); /// Return the deep merge of the samples of deep\nimages `A` and `B`, /// overwriting any existing samples of `dst` in the ROI. If\n/// `occlusion_cull` is true, any samples occluded by an opaque sample will ///\nbe deleted. ImageBuf OIIO_API deep_merge (const ImageBuf &A, const ImageBuf &B,\nbool occlusion_cull = true, ROI roi={}, int nthreads=0); /// Write to an\nexisting image `dst` (allocating if it is uninitialized). bool OIIO_API\ndeep_merge (ImageBuf &dst, const ImageBuf &A, const ImageBuf &B, bool\nocclusion_cull = true, ROI roi={}, int nthreads=0); /// Return the samples of\ndeep image `src` that are closer than the opaque /// frontier of deep image\nholdout, returning true upon success and false /// for any failures. Samples of\n`src` that are farther than the first /// opaque sample of holdout (for the\ncorresponding pixel) will not be copied /// to `dst`. Image holdout is only used\nas the depth threshold; no sample /// values from holdout are themselves copied\nto `dst`. ImageBuf OIIO_API deep_holdout (const ImageBuf &src, const ImageBuf\n&holdout, ROI roi={}, int nthreads=0); /// Write to an existing image `dst`\n(allocating if it is uninitialized). bool OIIO_API deep_holdout (ImageBuf &dst,\nconst ImageBuf &src, const ImageBuf &holdout, ROI roi={}, int nthreads=0);\n/////////////////////////////////////////////////////////////////////// //\nDEPRECATED functions follow: #ifndef DOXYGEN_SHOULD_SKIP_THIS\nOIIO_DEPRECATED(\"prefer the kind that takes an `inverse` parameter (2.5)\")\ninline ImageBuf ociodisplay (const ImageBuf &src, string_view display,\nstring_view view, string_view fromspace, string_view looks, bool unpremult,\nstring_view context_key, string_view context_value=\"\", const ColorConfig*\ncolorconfig = nullptr, ROI roi={}, int nthreads=0) { return ociodisplay(src,\ndisplay, view, fromspace, looks, unpremult, false, context_key, context_value,\ncolorconfig, roi, nthreads); } OIIO_DEPRECATED(\"prefer the kind that takes an\n`inverse` parameter (2.5)\") inline bool ociodisplay (ImageBuf &dst, const\nImageBuf &src, string_view display, string_view view, string_view fromspace,\nstring_view looks, bool unpremult, string_view context_key, string_view\ncontext_value=\"\", const ColorConfig* colorconfig = nullptr, ROI roi={}, int\nnthreads=0) { return ociodisplay(dst, src, display, view, fromspace, looks,\nunpremult, false, context_key, context_value, colorconfig, roi, nthreads); } //\nDEPRECATED(2.6) versions of functions that previously directly took a // filter\nname and width, or a raw pointer to a Filter2D, and sometimes a // separate wrap\nmode. These have been replaced by the versions that use a // KWArgs for options\nincluding all the filtering parameters. ImageBuf OIIO_API warp (const ImageBuf\n&src, M33fParam M, string_view filtername, float filterwidth = 0.0f, bool\nrecompute_roi = false, ImageBuf::WrapMode wrap = ImageBuf::WrapDefault, ROI\nroi={}, int nthreads=0); ImageBuf OIIO_API warp (const ImageBuf &src, M33fParam\nM, const Filter2D *filter, bool recompute_roi = false, ImageBuf::WrapMode wrap =\nImageBuf::WrapDefault, ROI roi = {}, int nthreads=0); bool OIIO_API warp\n(ImageBuf &dst, const ImageBuf &src, M33fParam M, string_view filtername, float\nfilterwidth = 0.0f, bool recompute_roi = false, ImageBuf::WrapMode wrap =\nImageBuf::WrapDefault, ROI roi={}, int nthreads=0); bool OIIO_API warp (ImageBuf\n&dst, const ImageBuf &src, M33fParam M, const Filter2D *filter, bool\nrecompute_roi = false, ImageBuf::WrapMode wrap = ImageBuf::WrapDefault, ROI roi\n= {}, int nthreads=0); OIIO_DEPRECATED(\"prefer the kind that takes keyword args\n(3.0)\") inline ImageBuf resize(const ImageBuf &src, string_view filtername,\nfloat filterwidth=0.0f, ROI roi={}, int nthreads=0) { return resize(src,{ {\n\"filtername\", filtername }, { \"filterwidth\", filterwidth } }, roi, nthreads); }\nOIIO_DEPRECATED(\"prefer the kind that takes keyword args (3.0)\") inline ImageBuf\nresize(const ImageBuf &src, Filter2D *filter, ROI roi={}, int nthreads=0) {\nreturn resize(src, { make_pv(\"filterptr\", filter) }, roi, nthreads); }\nOIIO_DEPRECATED(\"prefer the kind that takes keyword args (3.0)\") inline bool\nresize (ImageBuf &dst, const ImageBuf &src, string_view filtername, float\nfilterwidth, ROI roi={}, int nthreads=0) { return resize(dst, src, { {\n\"filtername\", filtername }, { \"filterwidth\", filterwidth } }, roi, nthreads); }\nOIIO_DEPRECATED(\"prefer the kind that takes keyword args (3.0)\") inline bool\nresize(ImageBuf &dst, const ImageBuf &src, Filter2D *filter, ROI roi={}, int\nnthreads=0) { return resize(dst, src, { make_pv(\"filterptr\", filter) }, roi,\nnthreads); } OIIO_DEPRECATED(\"prefer the kind that takes keyword args (3.0)\")\ninline ImageBuf fit(const ImageBuf &src, string_view filtername = \"\", float\nfilterwidth=0.0f, string_view fillmode=\"letterbox\", bool exact=false, ROI\nroi={}, int nthreads=0) { return fit(src, { { \"filtername\", filtername }, {\n\"filterwidth\", filterwidth }, { \"fillmode\", fillmode }, { \"exact\", int(exact) }\n}, roi, nthreads); } OIIO_DEPRECATED(\"prefer the kind that takes keyword args\n(3.0)\") inline ImageBuf fit(const ImageBuf &src, Filter2D *filter, string_view\nfillmode=\"letterbox\", bool exact=false, ROI roi={}, int nthreads=0) { return\nfit(src, { make_pv(\"filterptr\", filter), { \"fillmode\", fillmode }, { \"exact\",\nint(exact) } }, roi, nthreads); } OIIO_DEPRECATED(\"prefer the kind that takes\nkeyword args (3.0)\") inline bool fit(ImageBuf &dst, const ImageBuf &src,\nstring_view filtername = \"\", float filterwidth=0.0f, string_view\nfillmode=\"letterbox\", bool exact=false, ROI roi={}, int nthreads=0) { return\nfit(dst, src, { { \"filtername\", filtername }, { \"filterwidth\", filterwidth }, {\n\"fillmode\", fillmode }, { \"exact\", int(exact) } }, roi, nthreads); }\nOIIO_DEPRECATED(\"prefer the kind that takes keyword args (3.0)\") inline bool\nfit(ImageBuf &dst, const ImageBuf &src, Filter2D *filter, string_view\nfillmode=\"letterbox\", bool exact=false, ROI roi={}, int nthreads=0) { return\nfit(dst, src, { make_pv(\"filterptr\", filter), { \"fillmode\", fillmode }, {\n\"exact\", int(exact) } }, roi, nthreads); } // DEPRECATED(2.3): old versions\nlacking the \"fillmode\" parameter OIIO_DEPRECATED(\"prefer the kind that takes\nkeyword args (3.0)\") inline ImageBuf fit(const ImageBuf &src, string_view\nfiltername, float filterwidth, bool exact, ROI roi={}, int nthreads=0) { return\nfit(src, { { \"filtername\", filtername }, { \"filterwidth\", filterwidth }, {\n\"fillmode\", \"letterbox\" }, { \"exact\", int(exact) } }, roi, nthreads); }\nOIIO_DEPRECATED(\"prefer the kind that takes keyword args (3.0)\") inline ImageBuf\nfit(const ImageBuf &src, Filter2D *filter, bool exact, ROI roi={}, int\nnthreads=0) { return fit(src, { make_pv(\"filterptr\", filter), { \"fillmode\",\n\"letterbox\" }, { \"exact\", int(exact) } }, roi, nthreads); }\nOIIO_DEPRECATED(\"prefer the kind that takes keyword args (3.0)\") inline bool\nfit(ImageBuf &dst, const ImageBuf &src, string_view filtername, float\nfilterwidth, bool exact, ROI roi={}, int nthreads=0) { return fit(dst, src, { {\n\"filtername\", filtername }, { \"filterwidth\", filterwidth }, { \"fillmode\",\n\"letterbox\" }, { \"exact\", int(exact) } }, roi, nthreads); }\nOIIO_DEPRECATED(\"prefer the kind that takes keyword args (3.0)\") inline bool\nfit(ImageBuf &dst, const ImageBuf &src, Filter2D *filter, bool exact, ROI\nroi={}, int nthreads=0) { return fit(dst, src, { make_pv(\"filterptr\", filter), {\n\"fillmode\", \"letterbox\" }, { \"exact\", int(exact) } }, roi, nthreads); } #endif\n// DOXYGEN_SHOULD_SKIP_THIS\n/////////////////////////////////////////////////////////////////////// } // end\nnamespace ImageBufAlgo OIIO_NAMESPACE_END // Compatibility OIIO_NAMESPACE_BEGIN\n#ifndef OIIO_DOXYGEN using v3_1::Image_or_Const; namespace ImageBufAlgo { using\nnamespace OIIO::v3_1::ImageBufAlgo; } #endif OIIO_NAMESPACE_END\n","url":"https://raw.githubusercontent.com/AcademySoftwareFoundation/OpenImageIO/main/src/include/OpenImageIO/imagebufalgo.h"}
