diff --git a/crates/vfx-compute/Cargo.toml b/crates/vfx-compute/Cargo.toml
index af89274..b7a4304 100644
--- a/crates/vfx-compute/Cargo.toml
+++ b/crates/vfx-compute/Cargo.toml
@@ -40,5 +40,9 @@ windows = { version = "0.58", features = ["Win32_Graphics_Dxgi"] }
 [target.'cfg(target_os = "linux")'.dependencies]
 nvml-wrapper = { version = "0.10", optional = true }
 
+[target.'cfg(target_os = "macos")'.dependencies]
+objc2 = "0.5"
+objc2-metal = { version = "0.2", features = ["MTLDevice"] }
+
 [dev-dependencies]
 tempfile = { workspace = true }
diff --git a/crates/vfx-compute/src/backend/vram.rs b/crates/vfx-compute/src/backend/vram.rs
index 6bfb985..8351e1f 100644
--- a/crates/vfx-compute/src/backend/vram.rs
+++ b/crates/vfx-compute/src/backend/vram.rs
@@ -64,29 +64,24 @@ pub fn available_vram() -> u64 {
 
 fn detect_vram_impl() -> VramInfo {
     // Try platform-specific detection first
-    #[cfg(target_os = "windows")]
+    // Each function handles its own platform check internally
     if let Some(info) = detect_dxgi() {
         return info;
     }
 
-    #[cfg(target_os = "macos")]
     if let Some(info) = detect_metal() {
         return info;
     }
 
-    #[cfg(target_os = "linux")]
-    {
-        // Try NVML first (NVIDIA), then sysfs (AMD/Intel)
-        if let Some(info) = detect_nvml() {
-            return info;
-        }
-        if let Some(info) = detect_sysfs() {
-            return info;
-        }
+    // Try NVML first (NVIDIA), then sysfs (AMD/Intel)
+    if let Some(info) = detect_nvml() {
+        return info;
+    }
+    if let Some(info) = detect_sysfs() {
+        return info;
     }
 
     // Fallback to wgpu detection
-    #[cfg(feature = "wgpu")]
     if let Some(info) = detect_wgpu() {
         return info;
     }
@@ -169,10 +164,12 @@ fn detect_dxgi() -> Option<VramInfo> {
 
 #[cfg(target_os = "macos")]
 fn detect_metal() -> Option<VramInfo> {
-    use objc2::rc::Id;
-    use objc2_metal::MTLDevice;
+    use objc2::rc::Retained;
+    use objc2::runtime::ProtocolObject;
+    use objc2_metal::{MTLDevice, MTLCreateSystemDefaultDevice};
     
-    let device = unsafe { MTLDevice::systemDefaultDevice()? };
+    let device_ptr = unsafe { MTLCreateSystemDefaultDevice() };
+    let device: Retained<ProtocolObject<dyn MTLDevice>> = unsafe { Retained::from_raw(device_ptr)? };
     
     // recommendedMaxWorkingSetSize is the best estimate on Metal
     let total = device.recommendedMaxWorkingSetSize() as u64;
@@ -192,7 +189,6 @@ fn detect_metal() -> Option<VramInfo> {
 }
 
 #[cfg(not(target_os = "macos"))]
-#[allow(dead_code)]  // Needed for cross-platform compilation
 fn detect_metal() -> Option<VramInfo> {
     None
 }
@@ -219,7 +215,6 @@ fn detect_nvml() -> Option<VramInfo> {
 }
 
 #[cfg(not(target_os = "linux"))]
-#[allow(dead_code)]  // Needed for cross-platform compilation
 fn detect_nvml() -> Option<VramInfo> {
     None
 }
@@ -299,7 +294,6 @@ fn detect_sysfs() -> Option<VramInfo> {
 }
 
 #[cfg(not(target_os = "linux"))]
-#[allow(dead_code)]  // Needed for cross-platform compilation
 fn detect_sysfs() -> Option<VramInfo> {
     None
 }
@@ -345,7 +339,6 @@ fn detect_wgpu() -> Option<VramInfo> {
 }
 
 #[cfg(not(feature = "wgpu"))]
-#[allow(dead_code)]  // Needed when wgpu feature disabled
 fn detect_wgpu() -> Option<VramInfo> {
     None
 }
