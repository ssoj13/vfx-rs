//! Autodesk/Discreet .3dl LUT format support.
//!
//! The .3DL format is used by Autodesk Flame, Smoke, and Lustre.
//! It stores 3D LUT data with integer values (typically 10-bit or 12-bit).
//!
//! # Format
//!
//! ```text
//! # Comment (optional)
//! 0 32 64 96 128 ... 1023    (mesh/shaper defining input range)
//! 0 0 0                       (first RGB output, integers)
//! 1023 0 0
//! ...
//! 1023 1023 1023
//! ```
//!
//! # Variants
//!
//! - **Lustre format**: mesh line + RGB integers
//! - **Nuke format**: similar but may have different mesh scaling
//!
//! # Example
//!
//! ```rust,ignore
//! use vfx_lut::threedl;
//!
//! let lut = threedl::read_3dl("grade.3dl")?;
//! let rgb = lut.apply([0.5, 0.3, 0.2]);
//! ```

use crate::{Lut3D, LutError, LutResult};
use std::fs::File;
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::path::Path;

/// Reads a 3D LUT from a .3dl file.
pub fn read_3dl<P: AsRef<Path>>(path: P) -> LutResult<Lut3D> {
    let file = File::open(path.as_ref())?;
    let reader = BufReader::new(file);
    parse_3dl(reader)
}

/// Parses a 3D LUT from a .3dl reader.
pub fn parse_3dl<R: BufRead>(reader: R) -> LutResult<Lut3D> {
    let mut mesh: Option<Vec<i32>> = None;
    let mut data: Vec<[f32; 3]> = Vec::new();
    let mut max_value: i32 = 1023; // default 10-bit

    for line in reader.lines() {
        let line = line?;
        let line = line.trim();

        // Skip empty lines and comments
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.is_empty() {
            continue;
        }

        // Try to parse as integers
        let values: Result<Vec<i32>, _> = parts.iter().map(|s| s.parse::<i32>()).collect();

        match values {
            Ok(vals) => {
                if mesh.is_none() {
                    // First numeric line is the mesh (input range markers)
                    if !vals.is_empty() {
                        max_value = *vals.last().unwrap_or(&1023);
                        mesh = Some(vals);
                    }
                } else if vals.len() >= 3 {
                    // RGB data line
                    let r = vals[0] as f32 / max_value as f32;
                    let g = vals[1] as f32 / max_value as f32;
                    let b = vals[2] as f32 / max_value as f32;
                    data.push([r, g, b]);
                }
            }
            Err(_) => {
                // Not a valid integer line, skip
                continue;
            }
        }
    }

    // Determine cube size from data count
    let count = data.len();
    let size = (count as f64).cbrt().round() as usize;

    if size * size * size != count {
        return Err(LutError::ParseError(format!(
            "invalid 3DL data count {}, expected cube (e.g., 17^3=4913, 33^3=35937)",
            count
        )));
    }

    Lut3D::from_data(data, size)
}

/// Writes a 3D LUT to a .3dl file.
///
/// Uses 10-bit output (0-1023 range) by default.
pub fn write_3dl<P: AsRef<Path>>(path: P, lut: &Lut3D) -> LutResult<()> {
    write_3dl_with_depth(path, lut, 10)
}

/// Writes a 3D LUT to a .3dl file with specified bit depth.
///
/// # Arguments
///
/// * `path` - Output file path
/// * `lut` - The 3D LUT to write
/// * `bit_depth` - Output bit depth (10 or 12)
pub fn write_3dl_with_depth<P: AsRef<Path>>(path: P, lut: &Lut3D, bit_depth: u32) -> LutResult<()> {
    let file = File::create(path.as_ref())?;
    let mut writer = BufWriter::new(file);

    let max_value = (1 << bit_depth) - 1;
    let size = lut.size;

    // Write header comment
    writeln!(writer, "# Generated by vfx-lut")?;

    // Write mesh line (evenly spaced input values)
    let mesh: Vec<String> = (0..size)
        .map(|i| {
            let t = i as f32 / (size - 1) as f32;
            ((t * max_value as f32).round() as i32).to_string()
        })
        .collect();
    writeln!(writer, "{}", mesh.join(" "))?;

    // Write LUT data - R varies fastest, then G, then B
    for b_idx in 0..size {
        for g_idx in 0..size {
            for r_idx in 0..size {
                let idx = b_idx * size * size + g_idx * size + r_idx;
                let rgb = lut.data[idx];

                let r = (rgb[0].clamp(0.0, 1.0) * max_value as f32).round() as i32;
                let g = (rgb[1].clamp(0.0, 1.0) * max_value as f32).round() as i32;
                let b = (rgb[2].clamp(0.0, 1.0) * max_value as f32).round() as i32;

                writeln!(writer, "{} {} {}", r, g, b)?;
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Cursor;

    #[test]
    fn parse_3dl_basic() {
        // 2x2x2 cube with 10-bit values
        let content = r#"
# Test 3DL
0 1023
0 0 0
1023 0 0
0 1023 0
1023 1023 0
0 0 1023
1023 0 1023
0 1023 1023
1023 1023 1023
"#;
        let reader = Cursor::new(content);
        let lut = parse_3dl(reader).expect("parse failed");

        assert_eq!(lut.size, 2);

        // Check first entry (black)
        assert!((lut.data[0][0] - 0.0).abs() < 0.01);
        assert!((lut.data[0][1] - 0.0).abs() < 0.01);
        assert!((lut.data[0][2] - 0.0).abs() < 0.01);

        // Check last entry (white)
        let last = lut.data.len() - 1;
        assert!((lut.data[last][0] - 1.0).abs() < 0.01);
        assert!((lut.data[last][1] - 1.0).abs() < 0.01);
        assert!((lut.data[last][2] - 1.0).abs() < 0.01);
    }

    #[test]
    fn roundtrip_3dl() {
        let lut = Lut3D::identity(4);
        let temp_dir = std::env::temp_dir();
        let path = temp_dir.join("test_roundtrip.3dl");

        write_3dl(&path, &lut).expect("write failed");
        let loaded = read_3dl(&path).expect("read failed");

        assert_eq!(loaded.size, 4);

        // Check identity values are preserved
        for i in 0..4 {
            for j in 0..4 {
                for k in 0..4 {
                    let idx = k * 16 + j * 4 + i;
                    let expected_r = i as f32 / 3.0;
                    let expected_g = j as f32 / 3.0;
                    let expected_b = k as f32 / 3.0;

                    // Allow some quantization error (10-bit = 1/1023 resolution)
                    assert!((loaded.data[idx][0] - expected_r).abs() < 0.002);
                    assert!((loaded.data[idx][1] - expected_g).abs() < 0.002);
                    assert!((loaded.data[idx][2] - expected_b).abs() < 0.002);
                }
            }
        }

        let _ = std::fs::remove_file(&path);
    }

    #[test]
    fn parse_12bit_3dl() {
        // 2x2x2 cube with 12-bit values
        let content = r#"
0 4095
0 0 0
4095 0 0
0 4095 0
4095 4095 0
0 0 4095
4095 0 4095
0 4095 4095
4095 4095 4095
"#;
        let reader = Cursor::new(content);
        let lut = parse_3dl(reader).expect("parse failed");

        assert_eq!(lut.size, 2);

        // Check last entry (white at 12-bit)
        let last = lut.data.len() - 1;
        assert!((lut.data[last][0] - 1.0).abs() < 0.01);
    }
}
